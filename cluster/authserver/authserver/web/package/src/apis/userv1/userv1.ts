// @generated by protobuf-ts 2.10.0 with parameter long_type_number
// @generated from protobuf file "apis/protobuf/main/userv1/userv1.proto" (package "octelium.api.main.user.v1", syntax proto3)
// tslint:disable
//
// Copyright Octelium Labs, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { GetOptions } from "../metav1/metav1";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CommonListOptions } from "../metav1/metav1";
import { ListResponseMeta } from "../metav1/metav1";
import { DualStackNetwork } from "../metav1/metav1";
import { DualStackIP } from "../metav1/metav1";
import { Metadata } from "../metav1/metav1";
/**
 * @generated from protobuf message octelium.api.main.user.v1.LogoutRequest
 */
export interface LogoutRequest {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.LogoutResponse
 */
export interface LogoutResponse {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusRequest
 */
export interface GetStatusRequest {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse
 */
export interface GetStatusResponse {
    /**
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
    /**
     * Cluster is the Cluster's information.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.Cluster cluster = 2;
     */
    cluster?: GetStatusResponse_Cluster;
    /**
     * User is the User's information.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.User user = 3;
     */
    user?: GetStatusResponse_User;
    /**
     * Session is the Session's information.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.Session session = 4;
     */
    session?: GetStatusResponse_Session;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse.User
 */
export interface GetStatusResponse_User {
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.User.Spec spec = 2;
     */
    spec?: GetStatusResponse_User_Spec;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.User.Status status = 3;
     */
    status?: GetStatusResponse_User_Status;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse.User.Spec
 */
export interface GetStatusResponse_User_Spec {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse.User.Status
 */
export interface GetStatusResponse_User_Status {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse.Session
 */
export interface GetStatusResponse_Session {
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.Metadata metadata = 1;
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.Session.Spec spec = 2;
     */
    spec?: GetStatusResponse_Session_Spec;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.Session.Status status = 3;
     */
    status?: GetStatusResponse_Session_Status;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse.Session.Spec
 */
export interface GetStatusResponse_Session_Spec {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse.Session.Status
 */
export interface GetStatusResponse_Session_Status {
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.GetStatusResponse.Session.Status.Type type = 1;
     */
    type: GetStatusResponse_Session_Status_Type;
}
/**
 * @generated from protobuf enum octelium.api.main.user.v1.GetStatusResponse.Session.Status.Type
 */
export enum GetStatusResponse_Session_Status_Type {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * CLIENT is meant for client-based Sessions (i.e. the octelium client)
     *
     * @generated from protobuf enum value: CLIENT = 1;
     */
    CLIENT = 1,
    /**
     * CLIENTLESS is meant for client-less/BeyondCorp-based Sessions
     *
     * @generated from protobuf enum value: CLIENTLESS = 2;
     */
    CLIENTLESS = 2
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.GetStatusResponse.Cluster
 */
export interface GetStatusResponse_Cluster {
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.Metadata metadata = 1;
     */
    metadata?: Metadata;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectRequest
 */
export interface ConnectRequest {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "initialize";
        /**
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectRequest.Initialize initialize = 1;
         */
        initialize: ConnectRequest_Initialize;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize
 */
export interface ConnectRequest_Initialize {
    /**
     * L3Mode is the layer-3 mode supported by the Connection.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.ConnectRequest.Initialize.L3Mode l3Mode = 1;
     */
    l3Mode: ConnectRequest_Initialize_L3Mode;
    /**
     * ServiceOptions sets the hosted Services to be served by the Connection.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions serviceOptions = 2;
     */
    serviceOptions?: ConnectRequest_Initialize_ServiceOptions;
    /**
     * ConnectionType is the connection type
     *
     * @generated from protobuf field: octelium.api.main.user.v1.ConnectRequest.Initialize.ConnectionType connectionType = 3;
     */
    connectionType: ConnectRequest_Initialize_ConnectionType;
    /**
     * PublishedServices is the list of published Services to the client host
     *
     * @generated from protobuf field: repeated octelium.api.main.user.v1.ConnectRequest.Initialize.PublishedService publishedServices = 4;
     */
    publishedServices: ConnectRequest_Initialize_PublishedService[];
    /**
     * IgnoreDNS means that the client does not used the Cluster DNS
     *
     * @generated from protobuf field: bool ignoreDNS = 5;
     */
    ignoreDNS: boolean;
    /**
     * EnableESSH enables serving embedded SSH
     *
     * @generated from protobuf field: bool eSSHEnable = 6;
     */
    eSSHEnable: boolean;
    /**
     * Port is the listen port of the embedded SSH server
     *
     * @generated from protobuf field: int32 eSSHPort = 7;
     */
    eSSHPort: number;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions
 */
export interface ConnectRequest_Initialize_ServiceOptions {
    /**
     * ServeAll informs the Cluster that Connection is ready to serve all
     * Services that can be hosted by the owner User.
     *
     * @generated from protobuf field: bool serveAll = 1;
     */
    serveAll: boolean;
    /**
     * @generated from protobuf field: repeated octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions.Service services = 2;
     */
    services: ConnectRequest_Initialize_ServiceOptions_Service[];
    /**
     * @generated from protobuf field: string labelSelector = 3;
     */
    labelSelector: string;
    /**
     * PortStart informs the Cluster of the initial port number that should be
     * used for serving Services.
     *
     * @generated from protobuf field: int32 portStart = 4;
     */
    portStart: number;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions.Service
 */
export interface ConnectRequest_Initialize_ServiceOptions_Service {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize.PublishedService
 */
export interface ConnectRequest_Initialize_PublishedService {
    /**
     * Name is the Service name
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Port is the forwarded Service port number on the client host
     *
     * @generated from protobuf field: uint32 port = 2;
     */
    port: number;
    /**
     * Address is the forwarded Service host address
     *
     * @generated from protobuf field: string address = 3;
     */
    address: string;
}
/**
 * @generated from protobuf enum octelium.api.main.user.v1.ConnectRequest.Initialize.L3Mode
 */
export enum ConnectRequest_Initialize_L3Mode {
    /**
     * BOTH informs the Cluster that the Connection is ready for dual-stack.
     *
     * @generated from protobuf enum value: BOTH = 0;
     */
    BOTH = 0,
    /**
     * V4 informs the Cluster that the Connection only accepts IPv4.
     *
     * @generated from protobuf enum value: V4 = 1;
     */
    V4 = 1,
    /**
     * V6 informs the Cluster that the Connection only accepts IPv6.
     *
     * @generated from protobuf enum value: V6 = 2;
     */
    V6 = 2
}
/**
 * @generated from protobuf enum octelium.api.main.user.v1.ConnectRequest.Initialize.ConnectionType
 */
export enum ConnectRequest_Initialize_ConnectionType {
    /**
     * UNSET is not used
     *
     * @generated from protobuf enum value: UNSET = 0;
     */
    UNSET = 0,
    /**
     * WIREGUARD means that the connection is WireGuard
     *
     * @generated from protobuf enum value: WIREGUARD = 1;
     */
    WIREGUARD = 1,
    /**
     * QUICV0 means that the connection is QUICv0
     *
     * @generated from protobuf enum value: QUICV0 = 2;
     */
    QUICV0 = 2
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.DisconnectRequest
 */
export interface DisconnectRequest {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.DisconnectResponse
 */
export interface DisconnectResponse {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Gateway
 */
export interface Gateway {
    /**
     * ID is the Gateway's ID.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Addresses is the list of the Gateway's public addresses.
     *
     * @generated from protobuf field: repeated string addresses = 2;
     */
    addresses: string[];
    /**
     * CIDRs is the list of Gateway CIDRs.
     *
     * @generated from protobuf field: repeated string CIDRs = 3 [json_name = "CIDRs"];
     */
    cIDRs: string[];
    /**
     * @generated from protobuf field: string hostname = 4;
     */
    hostname: string;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.Gateway.WireGuard wireguard = 5;
     */
    wireguard?: Gateway_WireGuard;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.Gateway.QUICV0 quicv0 = 6;
     */
    quicv0?: Gateway_QUICV0;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Gateway.WireGuard
 */
export interface Gateway_WireGuard {
    /**
     * Port is the Gateway's WireGuard port.
     *
     * @generated from protobuf field: int32 port = 1;
     */
    port: number;
    /**
     * PublicKey is the Gateway's WireGuard curve25519 public key.
     *
     * @generated from protobuf field: string publicKey = 2;
     */
    publicKey: string;
    /**
     * CIDRs is the list of Gateway CIDRs.
     * KeepAliveSeconds is the number of seconds to periodically send
     * WireGuard's keepalive packets.
     *
     * @generated from protobuf field: int32 keepAliveSeconds = 3;
     */
    keepAliveSeconds: number;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Gateway.QUICV0
 */
export interface Gateway_QUICV0 {
    /**
     * Port is the Gateway's QUICv0 port.
     *
     * @generated from protobuf field: int32 port = 1;
     */
    port: number;
    /**
     * @generated from protobuf field: int32 keepAliveSeconds = 2;
     */
    keepAliveSeconds: number;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.DNS
 */
export interface DNS {
    /**
     * Servers is the list of the Cluster private DNS servers.
     *
     * @generated from protobuf field: repeated string servers = 1;
     */
    servers: string[];
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.HostedService
 */
export interface HostedService {
    /**
     * Name is the name of the hosted Service.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Port is the Service's port.
     *
     * @generated from protobuf field: uint32 port = 2;
     */
    port: number;
    /**
     * L4Type is the layer-4 type of the Service.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.HostedService.L4Type l4Type = 3;
     */
    l4Type: HostedService_L4Type;
    /**
     * Upstream is the listener upstream's information.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.HostedService.Upstream upstream = 4;
     */
    upstream?: HostedService_Upstream;
    /**
     * Address is the dual-stack address of the Service. It can be null for
     * upstreams listening on 0.0.0.0 or the Connection addresses.
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.DualStackIP address = 5;
     */
    address?: DualStackIP;
    /**
     * Mode is the hosted Service mode
     *
     * @generated from protobuf field: octelium.api.main.user.v1.HostedService.Mode mode = 6;
     */
    mode: HostedService_Mode;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.HostedService.Upstream
 */
export interface HostedService_Upstream {
    /**
     * Host is the upstream host
     *
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * Port is the upstream listen port
     *
     * @generated from protobuf field: int32 port = 2;
     */
    port: number;
}
/**
 * @generated from protobuf enum octelium.api.main.user.v1.HostedService.L4Type
 */
export enum HostedService_L4Type {
    /**
     * L4_UNKNOWN is not used
     *
     * @generated from protobuf enum value: L4_UNKNOWN = 0;
     */
    L4_UNKNOWN = 0,
    /**
     * TCP means that the Service is TCP-based
     *
     * @generated from protobuf enum value: TCP = 1;
     */
    TCP = 1,
    /**
     * UDP means that the Service is UDP-based
     *
     * @generated from protobuf enum value: UDP = 2;
     */
    UDP = 2
}
/**
 * @generated from protobuf enum octelium.api.main.user.v1.HostedService.Mode
 */
export enum HostedService_Mode {
    /**
     * MODE_UNSET is not used
     *
     * @generated from protobuf enum value: MODE_UNSET = 0;
     */
    UNSET = 0,
    /**
     * MODE_DEFAULT means that the hosted Service is served by an upstream
     *
     * @generated from protobuf enum value: MODE_DEFAULT = 1;
     */
    DEFAULT = 1,
    /**
     * MODE_ESSH means that the host Service is served by the embedded SSH
     * server
     *
     * @generated from protobuf enum value: MODE_ESSH = 2;
     */
    ESSH = 2
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectionState
 */
export interface ConnectionState {
    /**
     * MTU is the link MTU used at the client side
     *
     * @generated from protobuf field: int32 mtu = 1;
     */
    mtu: number;
    /**
     * X25519Key is the WireGuard private key used by the client
     *
     * @generated from protobuf field: bytes x25519Key = 2;
     */
    x25519Key: Uint8Array;
    /**
     * @generated from protobuf field: bytes ed25519Key = 3;
     */
    ed25519Key: Uint8Array;
    /**
     * Addresses is the list of the dual-stack addresses of the Connection.
     *
     * @generated from protobuf field: repeated octelium.api.main.meta.v1.DualStackNetwork addresses = 4;
     */
    addresses: DualStackNetwork[];
    /**
     * Gateways is the list of the Gateways.
     *
     * @generated from protobuf field: repeated octelium.api.main.user.v1.Gateway gateways = 5;
     */
    gateways: Gateway[];
    /**
     * DNS sets the private DNS information.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.DNS dns = 6;
     */
    dns?: DNS;
    /**
     * ServiceConfigs is the list of Service configs set to the client host
     *
     * @generated from protobuf field: repeated octelium.api.main.user.v1.ConnectionState.ServiceConfig serviceConfigs = 7;
     */
    serviceConfigs: ConnectionState_ServiceConfig[];
    /**
     * L3Mode sets the layer-3 mode approved by the Cluster.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.ConnectionState.L3Mode l3Mode = 8;
     */
    l3Mode: ConnectionState_L3Mode;
    /**
     * ServiceOptions is the hosted Service information.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.ConnectionState.ServiceOptions serviceOptions = 9;
     */
    serviceOptions?: ConnectionState_ServiceOptions;
    /**
     * CIDR is the Cluster Service CIDR.
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.DualStackNetwork cidr = 10;
     */
    cidr?: DualStackNetwork;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectionState.ServiceOptions
 */
export interface ConnectionState_ServiceOptions {
    /**
     * HostedServices is the list of hosted Services
     *
     * @generated from protobuf field: repeated octelium.api.main.user.v1.HostedService services = 1;
     */
    services: HostedService[];
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectionState.ServiceConfig
 */
export interface ConnectionState_ServiceConfig {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "ssh";
        /**
         * SSH sets SSH-specific Service config
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectionState.ServiceConfig.SSH ssh = 1;
         */
        ssh: ConnectionState_ServiceConfig_SSH;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectionState.ServiceConfig.SSH
 */
export interface ConnectionState_ServiceConfig_SSH {
    /**
     * KnownHosts is the list of SSH known hosts
     *
     * @generated from protobuf field: repeated string knownHosts = 1;
     */
    knownHosts: string[];
    /**
     * AuthorizedKeys is the list of SSH authorized keys
     *
     * @generated from protobuf field: repeated string authorizedKeys = 2;
     */
    authorizedKeys: string[];
}
/**
 * @generated from protobuf enum octelium.api.main.user.v1.ConnectionState.L3Mode
 */
export enum ConnectionState_L3Mode {
    /**
     * BOTH approves that the Connection is ready for dual-stack.
     *
     * @generated from protobuf enum value: BOTH = 0;
     */
    BOTH = 0,
    /**
     * V4 approves that the Connection is ready for IPv4 only.
     *
     * @generated from protobuf enum value: V4 = 1;
     */
    V4 = 1,
    /**
     * V6 approves that the Connection is ready for IPv6 only.
     *
     * @generated from protobuf enum value: V6 = 2;
     */
    V6 = 2
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Service
 */
export interface Service {
    /**
     * @generated from protobuf field: string apiVersion = 1;
     */
    apiVersion: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.Metadata metadata = 3;
     */
    metadata?: Metadata;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.Service.Spec spec = 4;
     */
    spec?: Service_Spec;
    /**
     * @generated from protobuf field: octelium.api.main.user.v1.Service.Status status = 5;
     */
    status?: Service_Status;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Service.Spec
 */
export interface Service_Spec {
    /**
     * Port is the Service listen port
     *
     * @generated from protobuf field: uint32 port = 1;
     */
    port: number;
    /**
     * Type is the Service tpye
     *
     * @generated from protobuf field: octelium.api.main.user.v1.Service.Spec.Type type = 2;
     */
    type: Service_Spec_Type;
    /**
     * IsTLS shows whether the Service is listening over TLS
     *
     * @generated from protobuf field: bool isTLS = 3;
     */
    isTLS: boolean;
    /**
     * IsPublic means that the Service is publicly exposed and can be accessed
     * via the client-less/BeyondCorp mode
     *
     * @generated from protobuf field: bool isPublic = 4;
     */
    isPublic: boolean;
}
/**
 * @generated from protobuf enum octelium.api.main.user.v1.Service.Spec.Type
 */
export enum Service_Spec_Type {
    /**
     * @generated from protobuf enum value: UNSET = 0;
     */
    UNSET = 0,
    /**
     * @generated from protobuf enum value: TCP = 1;
     */
    TCP = 1,
    /**
     * @generated from protobuf enum value: UDP = 2;
     */
    UDP = 2,
    /**
     * @generated from protobuf enum value: HTTP = 3;
     */
    HTTP = 3,
    /**
     * @generated from protobuf enum value: SSH = 4;
     */
    SSH = 4,
    /**
     * @generated from protobuf enum value: KUBERNETES = 5;
     */
    KUBERNETES = 5,
    /**
     * @generated from protobuf enum value: POSTGRES = 6;
     */
    POSTGRES = 6,
    /**
     * @generated from protobuf enum value: MYSQL = 7;
     */
    MYSQL = 7,
    /**
     * @generated from protobuf enum value: GRPC = 8;
     */
    GRPC = 8,
    /**
     * @generated from protobuf enum value: WEB = 9;
     */
    WEB = 9,
    /**
     * @generated from protobuf enum value: DNS = 10;
     */
    DNS = 10
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Service.Status
 */
export interface Service_Status {
    /**
     * Namespace is the Service's Namespace
     *
     * @generated from protobuf field: string namespace = 1;
     */
    namespace: string;
    /**
     * Addresses is the list of private addresses used by the Service
     *
     * @generated from protobuf field: repeated string addresses = 2;
     */
    addresses: string[];
    /**
     * PrimaryHostname is the unique primary hostname
     *
     * @generated from protobuf field: string primaryHostname = 3;
     */
    primaryHostname: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ServiceList
 */
export interface ServiceList {
    /**
     * @generated from protobuf field: string apiVersion = 1;
     */
    apiVersion: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: repeated octelium.api.main.user.v1.Service items = 3;
     */
    items: Service[];
    /**
     * ListResponseMeta is common information about the list.
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.ListResponseMeta listResponseMeta = 4;
     */
    listResponseMeta?: ListResponseMeta;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ListServiceOptions
 */
export interface ListServiceOptions {
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.CommonListOptions common = 1;
     */
    common?: CommonListOptions;
    /**
     * @generated from protobuf field: string namespace = 2;
     */
    namespace: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ListNamespaceOptions
 */
export interface ListNamespaceOptions {
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.CommonListOptions common = 1;
     */
    common?: CommonListOptions;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Namespace
 */
export interface Namespace {
    /**
     * @generated from protobuf field: string apiVersion = 1;
     */
    apiVersion: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * Metadata is the object's metadata.
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.Metadata metadata = 3;
     */
    metadata?: Metadata;
    /**
     * Spec is the Namespace specification.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.Namespace.Spec spec = 4;
     */
    spec?: Namespace_Spec;
    /**
     * Status is the current status of the Namespace.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.Namespace.Status status = 5;
     */
    status?: Namespace_Status;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Namespace.Spec
 */
export interface Namespace_Spec {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.Namespace.Status
 */
export interface Namespace_Status {
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.NamespaceList
 */
export interface NamespaceList {
    /**
     * APIVersion is the API version of the object.
     *
     * @generated from protobuf field: string apiVersion = 1;
     */
    apiVersion: string;
    /**
     * Kind is the resource name (i.e. `NamespaceList`).
     *
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * Items is the list of Namespaces.
     *
     * @generated from protobuf field: repeated octelium.api.main.user.v1.Namespace items = 3;
     */
    items: Namespace[];
    /**
     * ListResponseMeta is common information about the list.
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.ListResponseMeta listResponseMeta = 4;
     */
    listResponseMeta?: ListResponseMeta;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse
 */
export interface ConnectResponse {
    /**
     * @generated from protobuf oneof: Event
     */
    event: {
        oneofKind: "addGateway";
        /**
         * AddGateway is the event to add a Gateway.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.AddGateway addGateway = 1;
         */
        addGateway: ConnectResponse_AddGateway;
    } | {
        oneofKind: "updateGateway";
        /**
         * UpdateGateway is the event to update a Gateway.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.UpdateGateway updateGateway = 2;
         */
        updateGateway: ConnectResponse_UpdateGateway;
    } | {
        oneofKind: "deleteGateway";
        /**
         * DeleteGateway is the event to delete a Gateway.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.DeleteGateway deleteGateway = 3;
         */
        deleteGateway: ConnectResponse_DeleteGateway;
    } | {
        oneofKind: "updateDNS";
        /**
         * UpdateDNS is the event to update DNS.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.UpdateDNS updateDNS = 4;
         */
        updateDNS: ConnectResponse_UpdateDNS;
    } | {
        oneofKind: "message";
        /**
         * Message is the event to receive a custom message from the Cluster.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.Message message = 5;
         */
        message: ConnectResponse_Message;
    } | {
        oneofKind: "disconnect";
        /**
         * Disconnect is the event to disconnect from the Cluster.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.Disconnect disconnect = 6;
         */
        disconnect: ConnectResponse_Disconnect;
    } | {
        oneofKind: "addService";
        /**
         * AddService is the event to add a hosted Service.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.AddService addService = 7;
         */
        addService: ConnectResponse_AddService;
    } | {
        oneofKind: "updateService";
        /**
         * UpdateService is the event to update a hosted Service.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.UpdateService updateService = 8;
         */
        updateService: ConnectResponse_UpdateService;
    } | {
        oneofKind: "deleteService";
        /**
         * DeleteService is the event to delete a hosted Service.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectResponse.DeleteService deleteService = 9;
         */
        deleteService: ConnectResponse_DeleteService;
    } | {
        oneofKind: "state";
        /**
         * State is the event that sends the entire state of the Connection.
         *
         * @generated from protobuf field: octelium.api.main.user.v1.ConnectionState state = 10;
         */
        state: ConnectionState;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.AddGateway
 */
export interface ConnectResponse_AddGateway {
    /**
     * Gateway is the added Gateway.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.Gateway gateway = 1;
     */
    gateway?: Gateway;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.UpdateGateway
 */
export interface ConnectResponse_UpdateGateway {
    /**
     * Gateway is the updated Gateway.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.Gateway gateway = 1;
     */
    gateway?: Gateway;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.DeleteGateway
 */
export interface ConnectResponse_DeleteGateway {
    /**
     * ID is the ID of the Gateway that needs to be deleted.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.Disconnect
 */
export interface ConnectResponse_Disconnect {
    /**
     * Message is an optional message from the Cluster upon disconnect.
     * Currrently not used.
     *
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.Message
 */
export interface ConnectResponse_Message {
    /**
     * Message is a custom message from the Cluster.
     *
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.UpdateDNS
 */
export interface ConnectResponse_UpdateDNS {
    /**
     * DNS is the DNS information.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.DNS dns = 1;
     */
    dns?: DNS;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.AddService
 */
export interface ConnectResponse_AddService {
    /**
     * Service is the hosted Service that needs to be added.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.HostedService service = 1;
     */
    service?: HostedService;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.UpdateService
 */
export interface ConnectResponse_UpdateService {
    /**
     * Service is the hosted Service that needs to be updated.
     *
     * @generated from protobuf field: octelium.api.main.user.v1.HostedService service = 1;
     */
    service?: HostedService;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.ConnectResponse.DeleteService
 */
export interface ConnectResponse_DeleteService {
    /**
     * Name is the name of the Service that needs to be deleted.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.SetServiceConfigsRequest
 */
export interface SetServiceConfigsRequest {
    /**
     * Name is the Service name
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.SetServiceConfigsResponse
 */
export interface SetServiceConfigsResponse {
    /**
     * Configs is the list of configurations needed to be set at the client side
     * to use the Service
     *
     * @generated from protobuf field: repeated octelium.api.main.user.v1.SetServiceConfigsResponse.Config configs = 1;
     */
    configs: SetServiceConfigsResponse_Config[];
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.SetServiceConfigsResponse.Config
 */
export interface SetServiceConfigsResponse_Config {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "kubeconfig";
        /**
         * Kubeconfig sets kubeconfig-specific configurations
         *
         * @generated from protobuf field: octelium.api.main.user.v1.SetServiceConfigsResponse.Config.Kubeconfig kubeconfig = 1;
         */
        kubeconfig: SetServiceConfigsResponse_Config_Kubeconfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message octelium.api.main.user.v1.SetServiceConfigsResponse.Config.Kubeconfig
 */
export interface SetServiceConfigsResponse_Config_Kubeconfig {
    /**
     * Content is the kubeconfig content
     *
     * @generated from protobuf field: bytes content = 1;
     */
    content: Uint8Array;
}
// @generated message type with reflection information, may provide speed optimized methods
class LogoutRequest$Type extends MessageType<LogoutRequest> {
    constructor() {
        super("octelium.api.main.user.v1.LogoutRequest", []);
    }
    create(value?: PartialMessage<LogoutRequest>): LogoutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LogoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogoutRequest): LogoutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.LogoutRequest
 */
export const LogoutRequest = new LogoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogoutResponse$Type extends MessageType<LogoutResponse> {
    constructor() {
        super("octelium.api.main.user.v1.LogoutResponse", []);
    }
    create(value?: PartialMessage<LogoutResponse>): LogoutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LogoutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogoutResponse): LogoutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogoutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.LogoutResponse
 */
export const LogoutResponse = new LogoutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRequest$Type extends MessageType<GetStatusRequest> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusRequest", []);
    }
    create(value?: PartialMessage<GetStatusRequest>): GetStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRequest): GetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusRequest
 */
export const GetStatusRequest = new GetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse$Type extends MessageType<GetStatusResponse> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => GetStatusResponse_Cluster },
            { no: 3, name: "user", kind: "message", T: () => GetStatusResponse_User },
            { no: 4, name: "session", kind: "message", T: () => GetStatusResponse_Session }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse>): GetStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse): GetStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* octelium.api.main.user.v1.GetStatusResponse.Cluster cluster */ 2:
                    message.cluster = GetStatusResponse_Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* octelium.api.main.user.v1.GetStatusResponse.User user */ 3:
                    message.user = GetStatusResponse_User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* octelium.api.main.user.v1.GetStatusResponse.Session session */ 4:
                    message.session = GetStatusResponse_Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* octelium.api.main.user.v1.GetStatusResponse.Cluster cluster = 2; */
        if (message.cluster)
            GetStatusResponse_Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.GetStatusResponse.User user = 3; */
        if (message.user)
            GetStatusResponse_User.internalBinaryWrite(message.user, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.GetStatusResponse.Session session = 4; */
        if (message.session)
            GetStatusResponse_Session.internalBinaryWrite(message.session, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse
 */
export const GetStatusResponse = new GetStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_User$Type extends MessageType<GetStatusResponse_User> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse.User", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata },
            { no: 2, name: "spec", kind: "message", T: () => GetStatusResponse_User_Spec },
            { no: 3, name: "status", kind: "message", T: () => GetStatusResponse_User_Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse_User>): GetStatusResponse_User {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_User): GetStatusResponse_User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.meta.v1.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* octelium.api.main.user.v1.GetStatusResponse.User.Spec spec */ 2:
                    message.spec = GetStatusResponse_User_Spec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* octelium.api.main.user.v1.GetStatusResponse.User.Status status */ 3:
                    message.status = GetStatusResponse_User_Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.meta.v1.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.GetStatusResponse.User.Spec spec = 2; */
        if (message.spec)
            GetStatusResponse_User_Spec.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.GetStatusResponse.User.Status status = 3; */
        if (message.status)
            GetStatusResponse_User_Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse.User
 */
export const GetStatusResponse_User = new GetStatusResponse_User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_User_Spec$Type extends MessageType<GetStatusResponse_User_Spec> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse.User.Spec", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse_User_Spec>): GetStatusResponse_User_Spec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_User_Spec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_User_Spec): GetStatusResponse_User_Spec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_User_Spec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse.User.Spec
 */
export const GetStatusResponse_User_Spec = new GetStatusResponse_User_Spec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_User_Status$Type extends MessageType<GetStatusResponse_User_Status> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse.User.Status", []);
    }
    create(value?: PartialMessage<GetStatusResponse_User_Status>): GetStatusResponse_User_Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_User_Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_User_Status): GetStatusResponse_User_Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_User_Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse.User.Status
 */
export const GetStatusResponse_User_Status = new GetStatusResponse_User_Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_Session$Type extends MessageType<GetStatusResponse_Session> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse.Session", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata },
            { no: 2, name: "spec", kind: "message", T: () => GetStatusResponse_Session_Spec },
            { no: 3, name: "status", kind: "message", T: () => GetStatusResponse_Session_Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse_Session>): GetStatusResponse_Session {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_Session>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_Session): GetStatusResponse_Session {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.meta.v1.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* octelium.api.main.user.v1.GetStatusResponse.Session.Spec spec */ 2:
                    message.spec = GetStatusResponse_Session_Spec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* octelium.api.main.user.v1.GetStatusResponse.Session.Status status */ 3:
                    message.status = GetStatusResponse_Session_Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_Session, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.meta.v1.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.GetStatusResponse.Session.Spec spec = 2; */
        if (message.spec)
            GetStatusResponse_Session_Spec.internalBinaryWrite(message.spec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.GetStatusResponse.Session.Status status = 3; */
        if (message.status)
            GetStatusResponse_Session_Status.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse.Session
 */
export const GetStatusResponse_Session = new GetStatusResponse_Session$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_Session_Spec$Type extends MessageType<GetStatusResponse_Session_Spec> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse.Session.Spec", []);
    }
    create(value?: PartialMessage<GetStatusResponse_Session_Spec>): GetStatusResponse_Session_Spec {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_Session_Spec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_Session_Spec): GetStatusResponse_Session_Spec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_Session_Spec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse.Session.Spec
 */
export const GetStatusResponse_Session_Spec = new GetStatusResponse_Session_Spec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_Session_Status$Type extends MessageType<GetStatusResponse_Session_Status> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse.Session.Status", [
            { no: 1, name: "type", kind: "enum", T: () => ["octelium.api.main.user.v1.GetStatusResponse.Session.Status.Type", GetStatusResponse_Session_Status_Type] }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse_Session_Status>): GetStatusResponse_Session_Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_Session_Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_Session_Status): GetStatusResponse_Session_Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.GetStatusResponse.Session.Status.Type type */ 1:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_Session_Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.GetStatusResponse.Session.Status.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse.Session.Status
 */
export const GetStatusResponse_Session_Status = new GetStatusResponse_Session_Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusResponse_Cluster$Type extends MessageType<GetStatusResponse_Cluster> {
    constructor() {
        super("octelium.api.main.user.v1.GetStatusResponse.Cluster", [
            { no: 1, name: "metadata", kind: "message", T: () => Metadata }
        ]);
    }
    create(value?: PartialMessage<GetStatusResponse_Cluster>): GetStatusResponse_Cluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStatusResponse_Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusResponse_Cluster): GetStatusResponse_Cluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.meta.v1.Metadata metadata */ 1:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusResponse_Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.meta.v1.Metadata metadata = 1; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.GetStatusResponse.Cluster
 */
export const GetStatusResponse_Cluster = new GetStatusResponse_Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest$Type extends MessageType<ConnectRequest> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectRequest", [
            { no: 1, name: "initialize", kind: "message", oneof: "type", T: () => ConnectRequest_Initialize }
        ]);
    }
    create(value?: PartialMessage<ConnectRequest>): ConnectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ConnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectRequest): ConnectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.ConnectRequest.Initialize initialize */ 1:
                    message.type = {
                        oneofKind: "initialize",
                        initialize: ConnectRequest_Initialize.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).initialize)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.ConnectRequest.Initialize initialize = 1; */
        if (message.type.oneofKind === "initialize")
            ConnectRequest_Initialize.internalBinaryWrite(message.type.initialize, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectRequest
 */
export const ConnectRequest = new ConnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest_Initialize$Type extends MessageType<ConnectRequest_Initialize> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectRequest.Initialize", [
            { no: 1, name: "l3Mode", kind: "enum", T: () => ["octelium.api.main.user.v1.ConnectRequest.Initialize.L3Mode", ConnectRequest_Initialize_L3Mode] },
            { no: 2, name: "serviceOptions", kind: "message", T: () => ConnectRequest_Initialize_ServiceOptions },
            { no: 3, name: "connectionType", kind: "enum", T: () => ["octelium.api.main.user.v1.ConnectRequest.Initialize.ConnectionType", ConnectRequest_Initialize_ConnectionType] },
            { no: 4, name: "publishedServices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ConnectRequest_Initialize_PublishedService },
            { no: 5, name: "ignoreDNS", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "eSSHEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "eSSHPort", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectRequest_Initialize>): ConnectRequest_Initialize {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.l3Mode = 0;
        message.connectionType = 0;
        message.publishedServices = [];
        message.ignoreDNS = false;
        message.eSSHEnable = false;
        message.eSSHPort = 0;
        if (value !== undefined)
            reflectionMergePartial<ConnectRequest_Initialize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectRequest_Initialize): ConnectRequest_Initialize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.ConnectRequest.Initialize.L3Mode l3Mode */ 1:
                    message.l3Mode = reader.int32();
                    break;
                case /* octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions serviceOptions */ 2:
                    message.serviceOptions = ConnectRequest_Initialize_ServiceOptions.internalBinaryRead(reader, reader.uint32(), options, message.serviceOptions);
                    break;
                case /* octelium.api.main.user.v1.ConnectRequest.Initialize.ConnectionType connectionType */ 3:
                    message.connectionType = reader.int32();
                    break;
                case /* repeated octelium.api.main.user.v1.ConnectRequest.Initialize.PublishedService publishedServices */ 4:
                    message.publishedServices.push(ConnectRequest_Initialize_PublishedService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool ignoreDNS */ 5:
                    message.ignoreDNS = reader.bool();
                    break;
                case /* bool eSSHEnable */ 6:
                    message.eSSHEnable = reader.bool();
                    break;
                case /* int32 eSSHPort */ 7:
                    message.eSSHPort = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectRequest_Initialize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.ConnectRequest.Initialize.L3Mode l3Mode = 1; */
        if (message.l3Mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.l3Mode);
        /* octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions serviceOptions = 2; */
        if (message.serviceOptions)
            ConnectRequest_Initialize_ServiceOptions.internalBinaryWrite(message.serviceOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectRequest.Initialize.ConnectionType connectionType = 3; */
        if (message.connectionType !== 0)
            writer.tag(3, WireType.Varint).int32(message.connectionType);
        /* repeated octelium.api.main.user.v1.ConnectRequest.Initialize.PublishedService publishedServices = 4; */
        for (let i = 0; i < message.publishedServices.length; i++)
            ConnectRequest_Initialize_PublishedService.internalBinaryWrite(message.publishedServices[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool ignoreDNS = 5; */
        if (message.ignoreDNS !== false)
            writer.tag(5, WireType.Varint).bool(message.ignoreDNS);
        /* bool eSSHEnable = 6; */
        if (message.eSSHEnable !== false)
            writer.tag(6, WireType.Varint).bool(message.eSSHEnable);
        /* int32 eSSHPort = 7; */
        if (message.eSSHPort !== 0)
            writer.tag(7, WireType.Varint).int32(message.eSSHPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize
 */
export const ConnectRequest_Initialize = new ConnectRequest_Initialize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest_Initialize_ServiceOptions$Type extends MessageType<ConnectRequest_Initialize_ServiceOptions> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions", [
            { no: 1, name: "serveAll", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "services", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ConnectRequest_Initialize_ServiceOptions_Service },
            { no: 3, name: "labelSelector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "portStart", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectRequest_Initialize_ServiceOptions>): ConnectRequest_Initialize_ServiceOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serveAll = false;
        message.services = [];
        message.labelSelector = "";
        message.portStart = 0;
        if (value !== undefined)
            reflectionMergePartial<ConnectRequest_Initialize_ServiceOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectRequest_Initialize_ServiceOptions): ConnectRequest_Initialize_ServiceOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool serveAll */ 1:
                    message.serveAll = reader.bool();
                    break;
                case /* repeated octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions.Service services */ 2:
                    message.services.push(ConnectRequest_Initialize_ServiceOptions_Service.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string labelSelector */ 3:
                    message.labelSelector = reader.string();
                    break;
                case /* int32 portStart */ 4:
                    message.portStart = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectRequest_Initialize_ServiceOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool serveAll = 1; */
        if (message.serveAll !== false)
            writer.tag(1, WireType.Varint).bool(message.serveAll);
        /* repeated octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions.Service services = 2; */
        for (let i = 0; i < message.services.length; i++)
            ConnectRequest_Initialize_ServiceOptions_Service.internalBinaryWrite(message.services[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string labelSelector = 3; */
        if (message.labelSelector !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.labelSelector);
        /* int32 portStart = 4; */
        if (message.portStart !== 0)
            writer.tag(4, WireType.Varint).int32(message.portStart);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions
 */
export const ConnectRequest_Initialize_ServiceOptions = new ConnectRequest_Initialize_ServiceOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest_Initialize_ServiceOptions_Service$Type extends MessageType<ConnectRequest_Initialize_ServiceOptions_Service> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions.Service", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectRequest_Initialize_ServiceOptions_Service>): ConnectRequest_Initialize_ServiceOptions_Service {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectRequest_Initialize_ServiceOptions_Service>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectRequest_Initialize_ServiceOptions_Service): ConnectRequest_Initialize_ServiceOptions_Service {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectRequest_Initialize_ServiceOptions_Service, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize.ServiceOptions.Service
 */
export const ConnectRequest_Initialize_ServiceOptions_Service = new ConnectRequest_Initialize_ServiceOptions_Service$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest_Initialize_PublishedService$Type extends MessageType<ConnectRequest_Initialize_PublishedService> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectRequest.Initialize.PublishedService", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectRequest_Initialize_PublishedService>): ConnectRequest_Initialize_PublishedService {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.port = 0;
        message.address = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectRequest_Initialize_PublishedService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectRequest_Initialize_PublishedService): ConnectRequest_Initialize_PublishedService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectRequest_Initialize_PublishedService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).uint32(message.port);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectRequest.Initialize.PublishedService
 */
export const ConnectRequest_Initialize_PublishedService = new ConnectRequest_Initialize_PublishedService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectRequest$Type extends MessageType<DisconnectRequest> {
    constructor() {
        super("octelium.api.main.user.v1.DisconnectRequest", []);
    }
    create(value?: PartialMessage<DisconnectRequest>): DisconnectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DisconnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectRequest): DisconnectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisconnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.DisconnectRequest
 */
export const DisconnectRequest = new DisconnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectResponse$Type extends MessageType<DisconnectResponse> {
    constructor() {
        super("octelium.api.main.user.v1.DisconnectResponse", []);
    }
    create(value?: PartialMessage<DisconnectResponse>): DisconnectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DisconnectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectResponse): DisconnectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisconnectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.DisconnectResponse
 */
export const DisconnectResponse = new DisconnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gateway$Type extends MessageType<Gateway> {
    constructor() {
        super("octelium.api.main.user.v1.Gateway", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "CIDRs", kind: "scalar", jsonName: "CIDRs", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "wireguard", kind: "message", T: () => Gateway_WireGuard },
            { no: 6, name: "quicv0", kind: "message", T: () => Gateway_QUICV0 }
        ]);
    }
    create(value?: PartialMessage<Gateway>): Gateway {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.addresses = [];
        message.cIDRs = [];
        message.hostname = "";
        if (value !== undefined)
            reflectionMergePartial<Gateway>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gateway): Gateway {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string addresses */ 2:
                    message.addresses.push(reader.string());
                    break;
                case /* repeated string CIDRs = 3 [json_name = "CIDRs"];*/ 3:
                    message.cIDRs.push(reader.string());
                    break;
                case /* string hostname */ 4:
                    message.hostname = reader.string();
                    break;
                case /* octelium.api.main.user.v1.Gateway.WireGuard wireguard */ 5:
                    message.wireguard = Gateway_WireGuard.internalBinaryRead(reader, reader.uint32(), options, message.wireguard);
                    break;
                case /* octelium.api.main.user.v1.Gateway.QUICV0 quicv0 */ 6:
                    message.quicv0 = Gateway_QUICV0.internalBinaryRead(reader, reader.uint32(), options, message.quicv0);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gateway, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string addresses = 2; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.addresses[i]);
        /* repeated string CIDRs = 3 [json_name = "CIDRs"]; */
        for (let i = 0; i < message.cIDRs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cIDRs[i]);
        /* string hostname = 4; */
        if (message.hostname !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hostname);
        /* octelium.api.main.user.v1.Gateway.WireGuard wireguard = 5; */
        if (message.wireguard)
            Gateway_WireGuard.internalBinaryWrite(message.wireguard, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.Gateway.QUICV0 quicv0 = 6; */
        if (message.quicv0)
            Gateway_QUICV0.internalBinaryWrite(message.quicv0, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Gateway
 */
export const Gateway = new Gateway$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gateway_WireGuard$Type extends MessageType<Gateway_WireGuard> {
    constructor() {
        super("octelium.api.main.user.v1.Gateway.WireGuard", [
            { no: 1, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keepAliveSeconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Gateway_WireGuard>): Gateway_WireGuard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        message.publicKey = "";
        message.keepAliveSeconds = 0;
        if (value !== undefined)
            reflectionMergePartial<Gateway_WireGuard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gateway_WireGuard): Gateway_WireGuard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 port */ 1:
                    message.port = reader.int32();
                    break;
                case /* string publicKey */ 2:
                    message.publicKey = reader.string();
                    break;
                case /* int32 keepAliveSeconds */ 3:
                    message.keepAliveSeconds = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gateway_WireGuard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).int32(message.port);
        /* string publicKey = 2; */
        if (message.publicKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.publicKey);
        /* int32 keepAliveSeconds = 3; */
        if (message.keepAliveSeconds !== 0)
            writer.tag(3, WireType.Varint).int32(message.keepAliveSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Gateway.WireGuard
 */
export const Gateway_WireGuard = new Gateway_WireGuard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gateway_QUICV0$Type extends MessageType<Gateway_QUICV0> {
    constructor() {
        super("octelium.api.main.user.v1.Gateway.QUICV0", [
            { no: 1, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "keepAliveSeconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Gateway_QUICV0>): Gateway_QUICV0 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        message.keepAliveSeconds = 0;
        if (value !== undefined)
            reflectionMergePartial<Gateway_QUICV0>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gateway_QUICV0): Gateway_QUICV0 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 port */ 1:
                    message.port = reader.int32();
                    break;
                case /* int32 keepAliveSeconds */ 2:
                    message.keepAliveSeconds = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gateway_QUICV0, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).int32(message.port);
        /* int32 keepAliveSeconds = 2; */
        if (message.keepAliveSeconds !== 0)
            writer.tag(2, WireType.Varint).int32(message.keepAliveSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Gateway.QUICV0
 */
export const Gateway_QUICV0 = new Gateway_QUICV0$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DNS$Type extends MessageType<DNS> {
    constructor() {
        super("octelium.api.main.user.v1.DNS", [
            { no: 1, name: "servers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DNS>): DNS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.servers = [];
        if (value !== undefined)
            reflectionMergePartial<DNS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DNS): DNS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string servers */ 1:
                    message.servers.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DNS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string servers = 1; */
        for (let i = 0; i < message.servers.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.servers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.DNS
 */
export const DNS = new DNS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostedService$Type extends MessageType<HostedService> {
    constructor() {
        super("octelium.api.main.user.v1.HostedService", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "l4Type", kind: "enum", T: () => ["octelium.api.main.user.v1.HostedService.L4Type", HostedService_L4Type] },
            { no: 4, name: "upstream", kind: "message", T: () => HostedService_Upstream },
            { no: 5, name: "address", kind: "message", T: () => DualStackIP },
            { no: 6, name: "mode", kind: "enum", T: () => ["octelium.api.main.user.v1.HostedService.Mode", HostedService_Mode, "MODE_"] }
        ]);
    }
    create(value?: PartialMessage<HostedService>): HostedService {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.port = 0;
        message.l4Type = 0;
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<HostedService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostedService): HostedService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                case /* octelium.api.main.user.v1.HostedService.L4Type l4Type */ 3:
                    message.l4Type = reader.int32();
                    break;
                case /* octelium.api.main.user.v1.HostedService.Upstream upstream */ 4:
                    message.upstream = HostedService_Upstream.internalBinaryRead(reader, reader.uint32(), options, message.upstream);
                    break;
                case /* octelium.api.main.meta.v1.DualStackIP address */ 5:
                    message.address = DualStackIP.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* octelium.api.main.user.v1.HostedService.Mode mode */ 6:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostedService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).uint32(message.port);
        /* octelium.api.main.user.v1.HostedService.L4Type l4Type = 3; */
        if (message.l4Type !== 0)
            writer.tag(3, WireType.Varint).int32(message.l4Type);
        /* octelium.api.main.user.v1.HostedService.Upstream upstream = 4; */
        if (message.upstream)
            HostedService_Upstream.internalBinaryWrite(message.upstream, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.meta.v1.DualStackIP address = 5; */
        if (message.address)
            DualStackIP.internalBinaryWrite(message.address, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.HostedService.Mode mode = 6; */
        if (message.mode !== 0)
            writer.tag(6, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.HostedService
 */
export const HostedService = new HostedService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostedService_Upstream$Type extends MessageType<HostedService_Upstream> {
    constructor() {
        super("octelium.api.main.user.v1.HostedService.Upstream", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HostedService_Upstream>): HostedService_Upstream {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.host = "";
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<HostedService_Upstream>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostedService_Upstream): HostedService_Upstream {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostedService_Upstream, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.HostedService.Upstream
 */
export const HostedService_Upstream = new HostedService_Upstream$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionState$Type extends MessageType<ConnectionState> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectionState", [
            { no: 1, name: "mtu", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "x25519Key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "ed25519Key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "addresses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DualStackNetwork },
            { no: 5, name: "gateways", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Gateway },
            { no: 6, name: "dns", kind: "message", T: () => DNS },
            { no: 7, name: "serviceConfigs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ConnectionState_ServiceConfig },
            { no: 8, name: "l3Mode", kind: "enum", T: () => ["octelium.api.main.user.v1.ConnectionState.L3Mode", ConnectionState_L3Mode] },
            { no: 9, name: "serviceOptions", kind: "message", T: () => ConnectionState_ServiceOptions },
            { no: 10, name: "cidr", kind: "message", T: () => DualStackNetwork }
        ]);
    }
    create(value?: PartialMessage<ConnectionState>): ConnectionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mtu = 0;
        message.x25519Key = new Uint8Array(0);
        message.ed25519Key = new Uint8Array(0);
        message.addresses = [];
        message.gateways = [];
        message.serviceConfigs = [];
        message.l3Mode = 0;
        if (value !== undefined)
            reflectionMergePartial<ConnectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionState): ConnectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 mtu */ 1:
                    message.mtu = reader.int32();
                    break;
                case /* bytes x25519Key */ 2:
                    message.x25519Key = reader.bytes();
                    break;
                case /* bytes ed25519Key */ 3:
                    message.ed25519Key = reader.bytes();
                    break;
                case /* repeated octelium.api.main.meta.v1.DualStackNetwork addresses */ 4:
                    message.addresses.push(DualStackNetwork.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated octelium.api.main.user.v1.Gateway gateways */ 5:
                    message.gateways.push(Gateway.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* octelium.api.main.user.v1.DNS dns */ 6:
                    message.dns = DNS.internalBinaryRead(reader, reader.uint32(), options, message.dns);
                    break;
                case /* repeated octelium.api.main.user.v1.ConnectionState.ServiceConfig serviceConfigs */ 7:
                    message.serviceConfigs.push(ConnectionState_ServiceConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* octelium.api.main.user.v1.ConnectionState.L3Mode l3Mode */ 8:
                    message.l3Mode = reader.int32();
                    break;
                case /* octelium.api.main.user.v1.ConnectionState.ServiceOptions serviceOptions */ 9:
                    message.serviceOptions = ConnectionState_ServiceOptions.internalBinaryRead(reader, reader.uint32(), options, message.serviceOptions);
                    break;
                case /* octelium.api.main.meta.v1.DualStackNetwork cidr */ 10:
                    message.cidr = DualStackNetwork.internalBinaryRead(reader, reader.uint32(), options, message.cidr);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 mtu = 1; */
        if (message.mtu !== 0)
            writer.tag(1, WireType.Varint).int32(message.mtu);
        /* bytes x25519Key = 2; */
        if (message.x25519Key.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.x25519Key);
        /* bytes ed25519Key = 3; */
        if (message.ed25519Key.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.ed25519Key);
        /* repeated octelium.api.main.meta.v1.DualStackNetwork addresses = 4; */
        for (let i = 0; i < message.addresses.length; i++)
            DualStackNetwork.internalBinaryWrite(message.addresses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated octelium.api.main.user.v1.Gateway gateways = 5; */
        for (let i = 0; i < message.gateways.length; i++)
            Gateway.internalBinaryWrite(message.gateways[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.DNS dns = 6; */
        if (message.dns)
            DNS.internalBinaryWrite(message.dns, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated octelium.api.main.user.v1.ConnectionState.ServiceConfig serviceConfigs = 7; */
        for (let i = 0; i < message.serviceConfigs.length; i++)
            ConnectionState_ServiceConfig.internalBinaryWrite(message.serviceConfigs[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectionState.L3Mode l3Mode = 8; */
        if (message.l3Mode !== 0)
            writer.tag(8, WireType.Varint).int32(message.l3Mode);
        /* octelium.api.main.user.v1.ConnectionState.ServiceOptions serviceOptions = 9; */
        if (message.serviceOptions)
            ConnectionState_ServiceOptions.internalBinaryWrite(message.serviceOptions, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.meta.v1.DualStackNetwork cidr = 10; */
        if (message.cidr)
            DualStackNetwork.internalBinaryWrite(message.cidr, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectionState
 */
export const ConnectionState = new ConnectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionState_ServiceOptions$Type extends MessageType<ConnectionState_ServiceOptions> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectionState.ServiceOptions", [
            { no: 1, name: "services", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HostedService }
        ]);
    }
    create(value?: PartialMessage<ConnectionState_ServiceOptions>): ConnectionState_ServiceOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.services = [];
        if (value !== undefined)
            reflectionMergePartial<ConnectionState_ServiceOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionState_ServiceOptions): ConnectionState_ServiceOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated octelium.api.main.user.v1.HostedService services */ 1:
                    message.services.push(HostedService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionState_ServiceOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated octelium.api.main.user.v1.HostedService services = 1; */
        for (let i = 0; i < message.services.length; i++)
            HostedService.internalBinaryWrite(message.services[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectionState.ServiceOptions
 */
export const ConnectionState_ServiceOptions = new ConnectionState_ServiceOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionState_ServiceConfig$Type extends MessageType<ConnectionState_ServiceConfig> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectionState.ServiceConfig", [
            { no: 1, name: "ssh", kind: "message", oneof: "type", T: () => ConnectionState_ServiceConfig_SSH }
        ]);
    }
    create(value?: PartialMessage<ConnectionState_ServiceConfig>): ConnectionState_ServiceConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ConnectionState_ServiceConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionState_ServiceConfig): ConnectionState_ServiceConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.ConnectionState.ServiceConfig.SSH ssh */ 1:
                    message.type = {
                        oneofKind: "ssh",
                        ssh: ConnectionState_ServiceConfig_SSH.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).ssh)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionState_ServiceConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.ConnectionState.ServiceConfig.SSH ssh = 1; */
        if (message.type.oneofKind === "ssh")
            ConnectionState_ServiceConfig_SSH.internalBinaryWrite(message.type.ssh, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectionState.ServiceConfig
 */
export const ConnectionState_ServiceConfig = new ConnectionState_ServiceConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionState_ServiceConfig_SSH$Type extends MessageType<ConnectionState_ServiceConfig_SSH> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectionState.ServiceConfig.SSH", [
            { no: 1, name: "knownHosts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorizedKeys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectionState_ServiceConfig_SSH>): ConnectionState_ServiceConfig_SSH {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.knownHosts = [];
        message.authorizedKeys = [];
        if (value !== undefined)
            reflectionMergePartial<ConnectionState_ServiceConfig_SSH>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionState_ServiceConfig_SSH): ConnectionState_ServiceConfig_SSH {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string knownHosts */ 1:
                    message.knownHosts.push(reader.string());
                    break;
                case /* repeated string authorizedKeys */ 2:
                    message.authorizedKeys.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionState_ServiceConfig_SSH, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string knownHosts = 1; */
        for (let i = 0; i < message.knownHosts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.knownHosts[i]);
        /* repeated string authorizedKeys = 2; */
        for (let i = 0; i < message.authorizedKeys.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.authorizedKeys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectionState.ServiceConfig.SSH
 */
export const ConnectionState_ServiceConfig_SSH = new ConnectionState_ServiceConfig_SSH$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Service$Type extends MessageType<Service> {
    constructor() {
        super("octelium.api.main.user.v1.Service", [
            { no: 1, name: "apiVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "message", T: () => Metadata },
            { no: 4, name: "spec", kind: "message", T: () => Service_Spec },
            { no: 5, name: "status", kind: "message", T: () => Service_Status }
        ]);
    }
    create(value?: PartialMessage<Service>): Service {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiVersion = "";
        message.kind = "";
        if (value !== undefined)
            reflectionMergePartial<Service>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Service): Service {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string apiVersion */ 1:
                    message.apiVersion = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* octelium.api.main.meta.v1.Metadata metadata */ 3:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* octelium.api.main.user.v1.Service.Spec spec */ 4:
                    message.spec = Service_Spec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* octelium.api.main.user.v1.Service.Status status */ 5:
                    message.status = Service_Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Service, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string apiVersion = 1; */
        if (message.apiVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiVersion);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* octelium.api.main.meta.v1.Metadata metadata = 3; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.Service.Spec spec = 4; */
        if (message.spec)
            Service_Spec.internalBinaryWrite(message.spec, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.Service.Status status = 5; */
        if (message.status)
            Service_Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Service
 */
export const Service = new Service$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Service_Spec$Type extends MessageType<Service_Spec> {
    constructor() {
        super("octelium.api.main.user.v1.Service.Spec", [
            { no: 1, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["octelium.api.main.user.v1.Service.Spec.Type", Service_Spec_Type] },
            { no: 3, name: "isTLS", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "isPublic", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Service_Spec>): Service_Spec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        message.type = 0;
        message.isTLS = false;
        message.isPublic = false;
        if (value !== undefined)
            reflectionMergePartial<Service_Spec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Service_Spec): Service_Spec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 port */ 1:
                    message.port = reader.uint32();
                    break;
                case /* octelium.api.main.user.v1.Service.Spec.Type type */ 2:
                    message.type = reader.int32();
                    break;
                case /* bool isTLS */ 3:
                    message.isTLS = reader.bool();
                    break;
                case /* bool isPublic */ 4:
                    message.isPublic = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Service_Spec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).uint32(message.port);
        /* octelium.api.main.user.v1.Service.Spec.Type type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* bool isTLS = 3; */
        if (message.isTLS !== false)
            writer.tag(3, WireType.Varint).bool(message.isTLS);
        /* bool isPublic = 4; */
        if (message.isPublic !== false)
            writer.tag(4, WireType.Varint).bool(message.isPublic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Service.Spec
 */
export const Service_Spec = new Service_Spec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Service_Status$Type extends MessageType<Service_Status> {
    constructor() {
        super("octelium.api.main.user.v1.Service.Status", [
            { no: 1, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "primaryHostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Service_Status>): Service_Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.namespace = "";
        message.addresses = [];
        message.primaryHostname = "";
        if (value !== undefined)
            reflectionMergePartial<Service_Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Service_Status): Service_Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string namespace */ 1:
                    message.namespace = reader.string();
                    break;
                case /* repeated string addresses */ 2:
                    message.addresses.push(reader.string());
                    break;
                case /* string primaryHostname */ 3:
                    message.primaryHostname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Service_Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string namespace = 1; */
        if (message.namespace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.namespace);
        /* repeated string addresses = 2; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.addresses[i]);
        /* string primaryHostname = 3; */
        if (message.primaryHostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.primaryHostname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Service.Status
 */
export const Service_Status = new Service_Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceList$Type extends MessageType<ServiceList> {
    constructor() {
        super("octelium.api.main.user.v1.ServiceList", [
            { no: 1, name: "apiVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Service },
            { no: 4, name: "listResponseMeta", kind: "message", T: () => ListResponseMeta }
        ]);
    }
    create(value?: PartialMessage<ServiceList>): ServiceList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiVersion = "";
        message.kind = "";
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<ServiceList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceList): ServiceList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string apiVersion */ 1:
                    message.apiVersion = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* repeated octelium.api.main.user.v1.Service items */ 3:
                    message.items.push(Service.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* octelium.api.main.meta.v1.ListResponseMeta listResponseMeta */ 4:
                    message.listResponseMeta = ListResponseMeta.internalBinaryRead(reader, reader.uint32(), options, message.listResponseMeta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string apiVersion = 1; */
        if (message.apiVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiVersion);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* repeated octelium.api.main.user.v1.Service items = 3; */
        for (let i = 0; i < message.items.length; i++)
            Service.internalBinaryWrite(message.items[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.meta.v1.ListResponseMeta listResponseMeta = 4; */
        if (message.listResponseMeta)
            ListResponseMeta.internalBinaryWrite(message.listResponseMeta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ServiceList
 */
export const ServiceList = new ServiceList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListServiceOptions$Type extends MessageType<ListServiceOptions> {
    constructor() {
        super("octelium.api.main.user.v1.ListServiceOptions", [
            { no: 1, name: "common", kind: "message", T: () => CommonListOptions },
            { no: 2, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListServiceOptions>): ListServiceOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.namespace = "";
        if (value !== undefined)
            reflectionMergePartial<ListServiceOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListServiceOptions): ListServiceOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.meta.v1.CommonListOptions common */ 1:
                    message.common = CommonListOptions.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* string namespace */ 2:
                    message.namespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListServiceOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.meta.v1.CommonListOptions common = 1; */
        if (message.common)
            CommonListOptions.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string namespace = 2; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ListServiceOptions
 */
export const ListServiceOptions = new ListServiceOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListNamespaceOptions$Type extends MessageType<ListNamespaceOptions> {
    constructor() {
        super("octelium.api.main.user.v1.ListNamespaceOptions", [
            { no: 1, name: "common", kind: "message", T: () => CommonListOptions }
        ]);
    }
    create(value?: PartialMessage<ListNamespaceOptions>): ListNamespaceOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListNamespaceOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListNamespaceOptions): ListNamespaceOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.meta.v1.CommonListOptions common */ 1:
                    message.common = CommonListOptions.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListNamespaceOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.meta.v1.CommonListOptions common = 1; */
        if (message.common)
            CommonListOptions.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ListNamespaceOptions
 */
export const ListNamespaceOptions = new ListNamespaceOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Namespace$Type extends MessageType<Namespace> {
    constructor() {
        super("octelium.api.main.user.v1.Namespace", [
            { no: 1, name: "apiVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "message", T: () => Metadata },
            { no: 4, name: "spec", kind: "message", T: () => Namespace_Spec },
            { no: 5, name: "status", kind: "message", T: () => Namespace_Status }
        ]);
    }
    create(value?: PartialMessage<Namespace>): Namespace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiVersion = "";
        message.kind = "";
        if (value !== undefined)
            reflectionMergePartial<Namespace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Namespace): Namespace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string apiVersion */ 1:
                    message.apiVersion = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* octelium.api.main.meta.v1.Metadata metadata */ 3:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* octelium.api.main.user.v1.Namespace.Spec spec */ 4:
                    message.spec = Namespace_Spec.internalBinaryRead(reader, reader.uint32(), options, message.spec);
                    break;
                case /* octelium.api.main.user.v1.Namespace.Status status */ 5:
                    message.status = Namespace_Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Namespace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string apiVersion = 1; */
        if (message.apiVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiVersion);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* octelium.api.main.meta.v1.Metadata metadata = 3; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.Namespace.Spec spec = 4; */
        if (message.spec)
            Namespace_Spec.internalBinaryWrite(message.spec, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.Namespace.Status status = 5; */
        if (message.status)
            Namespace_Status.internalBinaryWrite(message.status, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Namespace
 */
export const Namespace = new Namespace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Namespace_Spec$Type extends MessageType<Namespace_Spec> {
    constructor() {
        super("octelium.api.main.user.v1.Namespace.Spec", []);
    }
    create(value?: PartialMessage<Namespace_Spec>): Namespace_Spec {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Namespace_Spec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Namespace_Spec): Namespace_Spec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Namespace_Spec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Namespace.Spec
 */
export const Namespace_Spec = new Namespace_Spec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Namespace_Status$Type extends MessageType<Namespace_Status> {
    constructor() {
        super("octelium.api.main.user.v1.Namespace.Status", []);
    }
    create(value?: PartialMessage<Namespace_Status>): Namespace_Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Namespace_Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Namespace_Status): Namespace_Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Namespace_Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.Namespace.Status
 */
export const Namespace_Status = new Namespace_Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamespaceList$Type extends MessageType<NamespaceList> {
    constructor() {
        super("octelium.api.main.user.v1.NamespaceList", [
            { no: 1, name: "apiVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Namespace },
            { no: 4, name: "listResponseMeta", kind: "message", T: () => ListResponseMeta }
        ]);
    }
    create(value?: PartialMessage<NamespaceList>): NamespaceList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiVersion = "";
        message.kind = "";
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<NamespaceList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamespaceList): NamespaceList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string apiVersion */ 1:
                    message.apiVersion = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* repeated octelium.api.main.user.v1.Namespace items */ 3:
                    message.items.push(Namespace.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* octelium.api.main.meta.v1.ListResponseMeta listResponseMeta */ 4:
                    message.listResponseMeta = ListResponseMeta.internalBinaryRead(reader, reader.uint32(), options, message.listResponseMeta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamespaceList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string apiVersion = 1; */
        if (message.apiVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiVersion);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* repeated octelium.api.main.user.v1.Namespace items = 3; */
        for (let i = 0; i < message.items.length; i++)
            Namespace.internalBinaryWrite(message.items[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.meta.v1.ListResponseMeta listResponseMeta = 4; */
        if (message.listResponseMeta)
            ListResponseMeta.internalBinaryWrite(message.listResponseMeta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.NamespaceList
 */
export const NamespaceList = new NamespaceList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse$Type extends MessageType<ConnectResponse> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse", [
            { no: 1, name: "addGateway", kind: "message", oneof: "event", T: () => ConnectResponse_AddGateway },
            { no: 2, name: "updateGateway", kind: "message", oneof: "event", T: () => ConnectResponse_UpdateGateway },
            { no: 3, name: "deleteGateway", kind: "message", oneof: "event", T: () => ConnectResponse_DeleteGateway },
            { no: 4, name: "updateDNS", kind: "message", oneof: "event", T: () => ConnectResponse_UpdateDNS },
            { no: 5, name: "message", kind: "message", oneof: "event", T: () => ConnectResponse_Message },
            { no: 6, name: "disconnect", kind: "message", oneof: "event", T: () => ConnectResponse_Disconnect },
            { no: 7, name: "addService", kind: "message", oneof: "event", T: () => ConnectResponse_AddService },
            { no: 8, name: "updateService", kind: "message", oneof: "event", T: () => ConnectResponse_UpdateService },
            { no: 9, name: "deleteService", kind: "message", oneof: "event", T: () => ConnectResponse_DeleteService },
            { no: 10, name: "state", kind: "message", oneof: "event", T: () => ConnectionState }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse>): ConnectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.event = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse): ConnectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.ConnectResponse.AddGateway addGateway */ 1:
                    message.event = {
                        oneofKind: "addGateway",
                        addGateway: ConnectResponse_AddGateway.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).addGateway)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.UpdateGateway updateGateway */ 2:
                    message.event = {
                        oneofKind: "updateGateway",
                        updateGateway: ConnectResponse_UpdateGateway.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).updateGateway)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.DeleteGateway deleteGateway */ 3:
                    message.event = {
                        oneofKind: "deleteGateway",
                        deleteGateway: ConnectResponse_DeleteGateway.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).deleteGateway)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.UpdateDNS updateDNS */ 4:
                    message.event = {
                        oneofKind: "updateDNS",
                        updateDNS: ConnectResponse_UpdateDNS.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).updateDNS)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.Message message */ 5:
                    message.event = {
                        oneofKind: "message",
                        message: ConnectResponse_Message.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).message)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.Disconnect disconnect */ 6:
                    message.event = {
                        oneofKind: "disconnect",
                        disconnect: ConnectResponse_Disconnect.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).disconnect)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.AddService addService */ 7:
                    message.event = {
                        oneofKind: "addService",
                        addService: ConnectResponse_AddService.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).addService)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.UpdateService updateService */ 8:
                    message.event = {
                        oneofKind: "updateService",
                        updateService: ConnectResponse_UpdateService.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).updateService)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectResponse.DeleteService deleteService */ 9:
                    message.event = {
                        oneofKind: "deleteService",
                        deleteService: ConnectResponse_DeleteService.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).deleteService)
                    };
                    break;
                case /* octelium.api.main.user.v1.ConnectionState state */ 10:
                    message.event = {
                        oneofKind: "state",
                        state: ConnectionState.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).state)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.ConnectResponse.AddGateway addGateway = 1; */
        if (message.event.oneofKind === "addGateway")
            ConnectResponse_AddGateway.internalBinaryWrite(message.event.addGateway, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.UpdateGateway updateGateway = 2; */
        if (message.event.oneofKind === "updateGateway")
            ConnectResponse_UpdateGateway.internalBinaryWrite(message.event.updateGateway, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.DeleteGateway deleteGateway = 3; */
        if (message.event.oneofKind === "deleteGateway")
            ConnectResponse_DeleteGateway.internalBinaryWrite(message.event.deleteGateway, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.UpdateDNS updateDNS = 4; */
        if (message.event.oneofKind === "updateDNS")
            ConnectResponse_UpdateDNS.internalBinaryWrite(message.event.updateDNS, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.Message message = 5; */
        if (message.event.oneofKind === "message")
            ConnectResponse_Message.internalBinaryWrite(message.event.message, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.Disconnect disconnect = 6; */
        if (message.event.oneofKind === "disconnect")
            ConnectResponse_Disconnect.internalBinaryWrite(message.event.disconnect, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.AddService addService = 7; */
        if (message.event.oneofKind === "addService")
            ConnectResponse_AddService.internalBinaryWrite(message.event.addService, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.UpdateService updateService = 8; */
        if (message.event.oneofKind === "updateService")
            ConnectResponse_UpdateService.internalBinaryWrite(message.event.updateService, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectResponse.DeleteService deleteService = 9; */
        if (message.event.oneofKind === "deleteService")
            ConnectResponse_DeleteService.internalBinaryWrite(message.event.deleteService, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.user.v1.ConnectionState state = 10; */
        if (message.event.oneofKind === "state")
            ConnectionState.internalBinaryWrite(message.event.state, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse
 */
export const ConnectResponse = new ConnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_AddGateway$Type extends MessageType<ConnectResponse_AddGateway> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.AddGateway", [
            { no: 1, name: "gateway", kind: "message", T: () => Gateway }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_AddGateway>): ConnectResponse_AddGateway {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_AddGateway>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_AddGateway): ConnectResponse_AddGateway {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.Gateway gateway */ 1:
                    message.gateway = Gateway.internalBinaryRead(reader, reader.uint32(), options, message.gateway);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_AddGateway, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.Gateway gateway = 1; */
        if (message.gateway)
            Gateway.internalBinaryWrite(message.gateway, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.AddGateway
 */
export const ConnectResponse_AddGateway = new ConnectResponse_AddGateway$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_UpdateGateway$Type extends MessageType<ConnectResponse_UpdateGateway> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.UpdateGateway", [
            { no: 1, name: "gateway", kind: "message", T: () => Gateway }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_UpdateGateway>): ConnectResponse_UpdateGateway {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_UpdateGateway>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_UpdateGateway): ConnectResponse_UpdateGateway {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.Gateway gateway */ 1:
                    message.gateway = Gateway.internalBinaryRead(reader, reader.uint32(), options, message.gateway);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_UpdateGateway, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.Gateway gateway = 1; */
        if (message.gateway)
            Gateway.internalBinaryWrite(message.gateway, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.UpdateGateway
 */
export const ConnectResponse_UpdateGateway = new ConnectResponse_UpdateGateway$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_DeleteGateway$Type extends MessageType<ConnectResponse_DeleteGateway> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.DeleteGateway", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_DeleteGateway>): ConnectResponse_DeleteGateway {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_DeleteGateway>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_DeleteGateway): ConnectResponse_DeleteGateway {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_DeleteGateway, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.DeleteGateway
 */
export const ConnectResponse_DeleteGateway = new ConnectResponse_DeleteGateway$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_Disconnect$Type extends MessageType<ConnectResponse_Disconnect> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.Disconnect", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_Disconnect>): ConnectResponse_Disconnect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_Disconnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_Disconnect): ConnectResponse_Disconnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_Disconnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.Disconnect
 */
export const ConnectResponse_Disconnect = new ConnectResponse_Disconnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_Message$Type extends MessageType<ConnectResponse_Message> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.Message", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_Message>): ConnectResponse_Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_Message): ConnectResponse_Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.Message
 */
export const ConnectResponse_Message = new ConnectResponse_Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_UpdateDNS$Type extends MessageType<ConnectResponse_UpdateDNS> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.UpdateDNS", [
            { no: 1, name: "dns", kind: "message", T: () => DNS }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_UpdateDNS>): ConnectResponse_UpdateDNS {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_UpdateDNS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_UpdateDNS): ConnectResponse_UpdateDNS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.DNS dns */ 1:
                    message.dns = DNS.internalBinaryRead(reader, reader.uint32(), options, message.dns);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_UpdateDNS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.DNS dns = 1; */
        if (message.dns)
            DNS.internalBinaryWrite(message.dns, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.UpdateDNS
 */
export const ConnectResponse_UpdateDNS = new ConnectResponse_UpdateDNS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_AddService$Type extends MessageType<ConnectResponse_AddService> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.AddService", [
            { no: 1, name: "service", kind: "message", T: () => HostedService }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_AddService>): ConnectResponse_AddService {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_AddService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_AddService): ConnectResponse_AddService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.HostedService service */ 1:
                    message.service = HostedService.internalBinaryRead(reader, reader.uint32(), options, message.service);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_AddService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.HostedService service = 1; */
        if (message.service)
            HostedService.internalBinaryWrite(message.service, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.AddService
 */
export const ConnectResponse_AddService = new ConnectResponse_AddService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_UpdateService$Type extends MessageType<ConnectResponse_UpdateService> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.UpdateService", [
            { no: 1, name: "service", kind: "message", T: () => HostedService }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_UpdateService>): ConnectResponse_UpdateService {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_UpdateService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_UpdateService): ConnectResponse_UpdateService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.HostedService service */ 1:
                    message.service = HostedService.internalBinaryRead(reader, reader.uint32(), options, message.service);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_UpdateService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.HostedService service = 1; */
        if (message.service)
            HostedService.internalBinaryWrite(message.service, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.UpdateService
 */
export const ConnectResponse_UpdateService = new ConnectResponse_UpdateService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse_DeleteService$Type extends MessageType<ConnectResponse_DeleteService> {
    constructor() {
        super("octelium.api.main.user.v1.ConnectResponse.DeleteService", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectResponse_DeleteService>): ConnectResponse_DeleteService {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse_DeleteService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse_DeleteService): ConnectResponse_DeleteService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse_DeleteService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.ConnectResponse.DeleteService
 */
export const ConnectResponse_DeleteService = new ConnectResponse_DeleteService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetServiceConfigsRequest$Type extends MessageType<SetServiceConfigsRequest> {
    constructor() {
        super("octelium.api.main.user.v1.SetServiceConfigsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetServiceConfigsRequest>): SetServiceConfigsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SetServiceConfigsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetServiceConfigsRequest): SetServiceConfigsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetServiceConfigsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.SetServiceConfigsRequest
 */
export const SetServiceConfigsRequest = new SetServiceConfigsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetServiceConfigsResponse$Type extends MessageType<SetServiceConfigsResponse> {
    constructor() {
        super("octelium.api.main.user.v1.SetServiceConfigsResponse", [
            { no: 1, name: "configs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SetServiceConfigsResponse_Config }
        ]);
    }
    create(value?: PartialMessage<SetServiceConfigsResponse>): SetServiceConfigsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configs = [];
        if (value !== undefined)
            reflectionMergePartial<SetServiceConfigsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetServiceConfigsResponse): SetServiceConfigsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated octelium.api.main.user.v1.SetServiceConfigsResponse.Config configs */ 1:
                    message.configs.push(SetServiceConfigsResponse_Config.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetServiceConfigsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated octelium.api.main.user.v1.SetServiceConfigsResponse.Config configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            SetServiceConfigsResponse_Config.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.SetServiceConfigsResponse
 */
export const SetServiceConfigsResponse = new SetServiceConfigsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetServiceConfigsResponse_Config$Type extends MessageType<SetServiceConfigsResponse_Config> {
    constructor() {
        super("octelium.api.main.user.v1.SetServiceConfigsResponse.Config", [
            { no: 1, name: "kubeconfig", kind: "message", oneof: "type", T: () => SetServiceConfigsResponse_Config_Kubeconfig }
        ]);
    }
    create(value?: PartialMessage<SetServiceConfigsResponse_Config>): SetServiceConfigsResponse_Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SetServiceConfigsResponse_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetServiceConfigsResponse_Config): SetServiceConfigsResponse_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.user.v1.SetServiceConfigsResponse.Config.Kubeconfig kubeconfig */ 1:
                    message.type = {
                        oneofKind: "kubeconfig",
                        kubeconfig: SetServiceConfigsResponse_Config_Kubeconfig.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).kubeconfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetServiceConfigsResponse_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.user.v1.SetServiceConfigsResponse.Config.Kubeconfig kubeconfig = 1; */
        if (message.type.oneofKind === "kubeconfig")
            SetServiceConfigsResponse_Config_Kubeconfig.internalBinaryWrite(message.type.kubeconfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.SetServiceConfigsResponse.Config
 */
export const SetServiceConfigsResponse_Config = new SetServiceConfigsResponse_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetServiceConfigsResponse_Config_Kubeconfig$Type extends MessageType<SetServiceConfigsResponse_Config_Kubeconfig> {
    constructor() {
        super("octelium.api.main.user.v1.SetServiceConfigsResponse.Config.Kubeconfig", [
            { no: 1, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SetServiceConfigsResponse_Config_Kubeconfig>): SetServiceConfigsResponse_Config_Kubeconfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.content = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SetServiceConfigsResponse_Config_Kubeconfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetServiceConfigsResponse_Config_Kubeconfig): SetServiceConfigsResponse_Config_Kubeconfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes content */ 1:
                    message.content = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetServiceConfigsResponse_Config_Kubeconfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes content = 1; */
        if (message.content.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.user.v1.SetServiceConfigsResponse.Config.Kubeconfig
 */
export const SetServiceConfigsResponse_Config_Kubeconfig = new SetServiceConfigsResponse_Config_Kubeconfig$Type();
/**
 * @generated ServiceType for protobuf service octelium.api.main.user.v1.MainService
 */
export const MainService = new ServiceType("octelium.api.main.user.v1.MainService", [
    { name: "Connect", serverStreaming: true, clientStreaming: true, options: {}, I: ConnectRequest, O: ConnectResponse },
    { name: "Disconnect", options: {}, I: DisconnectRequest, O: DisconnectResponse },
    { name: "ListService", options: {}, I: ListServiceOptions, O: ServiceList },
    { name: "ListNamespace", options: {}, I: ListNamespaceOptions, O: NamespaceList },
    { name: "GetStatus", options: {}, I: GetStatusRequest, O: GetStatusResponse },
    { name: "SetServiceConfigs", options: {}, I: SetServiceConfigsRequest, O: SetServiceConfigsResponse },
    { name: "GetService", options: {}, I: GetOptions, O: Service }
]);
