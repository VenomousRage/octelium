// @generated by protobuf-ts 2.10.0 with parameter long_type_number
// @generated from protobuf file "apis/protobuf/main/metav1/metav1.proto" (package "octelium.api.main.meta.v1", syntax proto3)
// tslint:disable
//
// Copyright Octelium Labs, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../google/protobuf/timestamp";
/**
 * @generated from protobuf message octelium.api.main.meta.v1.Metadata
 */
export interface Metadata {
    /**
     * UID is the unique UUID value for the object assigned by the Cluster.
     * Read-only.
     *
     * @generated from protobuf field: string uid = 1;
     */
    uid: string;
    /**
     * Name is the name of the object. It must be unique within a certain
     * API/Version/Kind tuple.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * CreatedAt is the timestamp of creation of the object. Read-only.
     *
     * @generated from protobuf field: google.protobuf.Timestamp createdAt = 3;
     */
    createdAt?: Timestamp;
    /**
     * UpdatedAt is the timestamp of when the object was last updated.
     * Read-only.
     *
     * @generated from protobuf field: google.protobuf.Timestamp updatedAt = 4;
     */
    updatedAt?: Timestamp;
    /**
     * DisplayName is the name that can be shown publicly for the object. Doesn't
     * need to be unique.
     *
     * @generated from protobuf field: string displayName = 5;
     */
    displayName: string;
    /**
     * Description is used to describe the object in a short sentence. Maximum
     * characters are 1000.
     *
     * @generated from protobuf field: string description = 6;
     */
    description: string;
    /**
     * Labels is a map of string keys and values to organize objects.
     *
     * @generated from protobuf field: map<string, string> labels = 7;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * Tags is an optional array of tags that classify the Resource.
     *
     * @generated from protobuf field: repeated string tags = 8;
     */
    tags: string[];
    /**
     * Labels is a map of string keys and values that can be used to store
     * metadata about the object.
     *
     * @generated from protobuf field: map<string, string> annotations = 9;
     */
    annotations: {
        [key: string]: string;
    };
    /**
     * PicURL is the Picture URL of the resource.
     *
     * @generated from protobuf field: string picURL = 10;
     */
    picURL: string;
    /**
     * ResourceVersion is a unique ID that represent the current version of the
     * resource object. Used by the Cluster to detect updates.
     *
     * @generated from protobuf field: string resourceVersion = 11;
     */
    resourceVersion: string;
    /**
     * LastResourceVersion is the ResourceVersion of the last update of the
     * Resource.
     *
     * @generated from protobuf field: string lastResourceVersion = 12;
     */
    lastResourceVersion: string;
    /**
     * ActorRef is the object reference to the Actor resource, typically a
     * Session, who is responsible for the current resource change. If ActorRef is
     * not set, then the current change of the resource was done by the Cluster
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.ObjectReference actorRef = 13;
     */
    actorRef?: ObjectReference;
    /**
     * ActorOperation is the gRPC full method triggered by the actorRef to modify
     * the Resource
     *
     * @generated from protobuf field: string actorOperation = 14;
     */
    actorOperation: string;
    /**
     * IsSystem means that the resource is created by the Cluster and it cannot be
     * managed by the administrators. Read-only.
     *
     * @generated from protobuf field: bool isSystem = 15;
     */
    isSystem: boolean;
    /**
     * SpecLabels is map used internally by the Cluster for quick searches among
     * lists of objects. Read-only.
     *
     * @generated from protobuf field: map<string, string> specLabels = 16;
     */
    specLabels: {
        [key: string]: string;
    };
    /**
     * IsUserHidden means that the resource object is hidden from ordinary Users
     * and should not be exposed via the User APIs.
     *
     * @generated from protobuf field: bool isUserHidden = 17;
     */
    isUserHidden: boolean;
    /**
     * IsSystemHidden means that the resource object is hidden by the Cluster and
     * should not be exposed via the APIs.
     *
     * @generated from protobuf field: bool isSystemHidden = 18;
     */
    isSystemHidden: boolean;
    /**
     * SystemLabels is a similar map to specLabels. Used only by the Cluster.
     *
     * @generated from protobuf field: map<string, string> systemLabels = 19;
     */
    systemLabels: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.ObjectReference
 */
export interface ObjectReference {
    /**
     * APIVersion is the API version of the reference resource
     *
     * @generated from protobuf field: string apiVersion = 1;
     */
    apiVersion: string;
    /**
     * Kind is the resource kind. A kind is unique per an APIVersion.
     *
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * UID is the resource object UID. A UID is unique across the entire Cluster.
     *
     * @generated from protobuf field: string uid = 3;
     */
    uid: string;
    /**
     * Name is the resource object name. A name is unique per a certain kind.
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * ResourceVersion is the resourceVersion of the resource.
     *
     * @generated from protobuf field: string resourceVersion = 5;
     */
    resourceVersion: string;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.Duration
 */
export interface Duration {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "milliseconds";
        /**
         * Milliseconds is the duration set in milliseconds
         *
         * @generated from protobuf field: uint32 milliseconds = 1;
         */
        milliseconds: number;
    } | {
        oneofKind: "seconds";
        /**
         * Seconds is the duration set in seconds
         *
         * @generated from protobuf field: uint32 seconds = 2;
         */
        seconds: number;
    } | {
        oneofKind: "minutes";
        /**
         * Minutes is the duration set in minutes
         *
         * @generated from protobuf field: uint32 minutes = 3;
         */
        minutes: number;
    } | {
        oneofKind: "hours";
        /**
         * Hours is the duration set in hours
         *
         * @generated from protobuf field: uint32 hours = 4;
         */
        hours: number;
    } | {
        oneofKind: "days";
        /**
         * Days is the duration set in days
         *
         * @generated from protobuf field: uint32 days = 5;
         */
        days: number;
    } | {
        oneofKind: "weeks";
        /**
         * Weeks is the duration set in weeks
         *
         * @generated from protobuf field: uint32 weeks = 6;
         */
        weeks: number;
    } | {
        oneofKind: "months";
        /**
         * Months is the duration set in months
         *
         * @generated from protobuf field: uint32 months = 7;
         */
        months: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.DeleteOptions
 */
export interface DeleteOptions {
    /**
     * UID is the objet's UID.
     *
     * @generated from protobuf field: string uid = 1;
     */
    uid: string;
    /**
     * Name is the object name that needs to be deleted. Either the name or the
     * UID must be used.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.GetOptions
 */
export interface GetOptions {
    /**
     * UID is the object's UID
     *
     * @generated from protobuf field: string uid = 1;
     */
    uid: string;
    /**
     * Name is the object's name
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.OperationResult
 */
export interface OperationResult {
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.DualStackIP
 */
export interface DualStackIP {
    /**
     * IPv4 is the IPv4 address.
     *
     * @generated from protobuf field: string ipv4 = 1;
     */
    ipv4: string;
    /**
     * IPv6 is the IPv6 address.
     *
     * @generated from protobuf field: string ipv6 = 2;
     */
    ipv6: string;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.DualStackNetwork
 */
export interface DualStackNetwork {
    /**
     * V4 is the IPv4 network address represented as CIDR notation IP address
     * and prefix length (e.g. `192.0.2.0/24`).
     *
     * @generated from protobuf field: string v4 = 1;
     */
    v4: string;
    /**
     * V6 is the IPv6 network address represented as CIDR notation IP address
     * and prefix length (e.g. `2001:db8::/32`).
     *
     * @generated from protobuf field: string v6 = 2;
     */
    v6: string;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.ListResponseMeta
 */
export interface ListResponseMeta {
    /**
     * Page is the page number. Starts with zero.
     *
     * @generated from protobuf field: uint32 page = 1;
     */
    page: number;
    /**
     * ItemsPerPage is number of items per page.
     *
     * @generated from protobuf field: uint32 itemsPerPage = 2;
     */
    itemsPerPage: number;
    /**
     * TotalCount is the total count of items that can be obtained.
     *
     * @generated from protobuf field: uint32 totalCount = 3;
     */
    totalCount: number;
    /**
     * HasMore shows whether there a next page is available
     *
     * @generated from protobuf field: bool hasMore = 4;
     */
    hasMore: boolean;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.LogMetadata
 */
export interface LogMetadata {
    /**
     * ID is the unique ID for the log entry
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * CreatedAt is the timestamp of creation.
     *
     * @generated from protobuf field: google.protobuf.Timestamp createdAt = 2;
     */
    createdAt?: Timestamp;
    /**
     * Actor is the actor whose action triggered the log entry (i.e. the User,
     * their Session and Device if available)
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.ObjectReference actorRef = 3;
     */
    actorRef?: ObjectReference;
    /**
     * Target is the target of the action that triggered the log entry (e.g. the
     * Service and its Namespace in the case of a SERVICE log entry)
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.ObjectReference targetRef = 4;
     */
    targetRef?: ObjectReference;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.CommonListOptions
 */
export interface CommonListOptions {
    /**
     * Page is the page number, starts at zero.
     *
     * @generated from protobuf field: uint32 page = 1;
     */
    page: number;
    /**
     * ItemsPerPage is the items per page
     *
     * @generated from protobuf field: uint32 itemsPerPage = 2;
     */
    itemsPerPage: number;
    /**
     * OrderBy orders the list
     *
     * @generated from protobuf field: octelium.api.main.meta.v1.CommonListOptions.OrderBy orderBy = 3;
     */
    orderBy?: CommonListOptions_OrderBy;
}
/**
 * @generated from protobuf message octelium.api.main.meta.v1.CommonListOptions.OrderBy
 */
export interface CommonListOptions_OrderBy {
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.CommonListOptions.OrderBy.Type type = 1;
     */
    type: CommonListOptions_OrderBy_Type;
    /**
     * @generated from protobuf field: octelium.api.main.meta.v1.CommonListOptions.OrderBy.Mode mode = 2;
     */
    mode: CommonListOptions_OrderBy_Mode;
}
/**
 * @generated from protobuf enum octelium.api.main.meta.v1.CommonListOptions.OrderBy.Type
 */
export enum CommonListOptions_OrderBy_Type {
    /**
     * @generated from protobuf enum value: TYPE_UNSET = 0;
     */
    TYPE_UNSET = 0,
    /**
     * @generated from protobuf enum value: NAME = 1;
     */
    NAME = 1,
    /**
     * @generated from protobuf enum value: CREATED_AT = 2;
     */
    CREATED_AT = 2
}
/**
 * @generated from protobuf enum octelium.api.main.meta.v1.CommonListOptions.OrderBy.Mode
 */
export enum CommonListOptions_OrderBy_Mode {
    /**
     * @generated from protobuf enum value: MODE_UNSET = 0;
     */
    MODE_UNSET = 0,
    /**
     * @generated from protobuf enum value: ASC = 1;
     */
    ASC = 1,
    /**
     * @generated from protobuf enum value: DESC = 2;
     */
    DESC = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("octelium.api.main.meta.v1.Metadata", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "createdAt", kind: "message", T: () => Timestamp },
            { no: 4, name: "updatedAt", kind: "message", T: () => Timestamp },
            { no: 5, name: "displayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "annotations", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 10, name: "picURL", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "resourceVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "lastResourceVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "actorRef", kind: "message", T: () => ObjectReference },
            { no: 14, name: "actorOperation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "isSystem", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "specLabels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 17, name: "isUserHidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "isSystemHidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "systemLabels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uid = "";
        message.name = "";
        message.displayName = "";
        message.description = "";
        message.labels = {};
        message.tags = [];
        message.annotations = {};
        message.picURL = "";
        message.resourceVersion = "";
        message.lastResourceVersion = "";
        message.actorOperation = "";
        message.isSystem = false;
        message.specLabels = {};
        message.isUserHidden = false;
        message.isSystemHidden = false;
        message.systemLabels = {};
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp createdAt */ 3:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updatedAt */ 4:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* string displayName */ 5:
                    message.displayName = reader.string();
                    break;
                case /* string description */ 6:
                    message.description = reader.string();
                    break;
                case /* map<string, string> labels */ 7:
                    this.binaryReadMap7(message.labels, reader, options);
                    break;
                case /* repeated string tags */ 8:
                    message.tags.push(reader.string());
                    break;
                case /* map<string, string> annotations */ 9:
                    this.binaryReadMap9(message.annotations, reader, options);
                    break;
                case /* string picURL */ 10:
                    message.picURL = reader.string();
                    break;
                case /* string resourceVersion */ 11:
                    message.resourceVersion = reader.string();
                    break;
                case /* string lastResourceVersion */ 12:
                    message.lastResourceVersion = reader.string();
                    break;
                case /* octelium.api.main.meta.v1.ObjectReference actorRef */ 13:
                    message.actorRef = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.actorRef);
                    break;
                case /* string actorOperation */ 14:
                    message.actorOperation = reader.string();
                    break;
                case /* bool isSystem */ 15:
                    message.isSystem = reader.bool();
                    break;
                case /* map<string, string> specLabels */ 16:
                    this.binaryReadMap16(message.specLabels, reader, options);
                    break;
                case /* bool isUserHidden */ 17:
                    message.isUserHidden = reader.bool();
                    break;
                case /* bool isSystemHidden */ 18:
                    message.isSystemHidden = reader.bool();
                    break;
                case /* map<string, string> systemLabels */ 19:
                    this.binaryReadMap19(message.systemLabels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: Metadata["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["labels"] | undefined, val: Metadata["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field octelium.api.main.meta.v1.Metadata.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap9(map: Metadata["annotations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["annotations"] | undefined, val: Metadata["annotations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field octelium.api.main.meta.v1.Metadata.annotations");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap16(map: Metadata["specLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["specLabels"] | undefined, val: Metadata["specLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field octelium.api.main.meta.v1.Metadata.specLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap19(map: Metadata["systemLabels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["systemLabels"] | undefined, val: Metadata["systemLabels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field octelium.api.main.meta.v1.Metadata.systemLabels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp createdAt = 3; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updatedAt = 4; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string displayName = 5; */
        if (message.displayName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.displayName);
        /* string description = 6; */
        if (message.description !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* map<string, string> labels = 7; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        /* repeated string tags = 8; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.tags[i]);
        /* map<string, string> annotations = 9; */
        for (let k of globalThis.Object.keys(message.annotations))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.annotations[k]).join();
        /* string picURL = 10; */
        if (message.picURL !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.picURL);
        /* string resourceVersion = 11; */
        if (message.resourceVersion !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.resourceVersion);
        /* string lastResourceVersion = 12; */
        if (message.lastResourceVersion !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.lastResourceVersion);
        /* octelium.api.main.meta.v1.ObjectReference actorRef = 13; */
        if (message.actorRef)
            ObjectReference.internalBinaryWrite(message.actorRef, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string actorOperation = 14; */
        if (message.actorOperation !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.actorOperation);
        /* bool isSystem = 15; */
        if (message.isSystem !== false)
            writer.tag(15, WireType.Varint).bool(message.isSystem);
        /* map<string, string> specLabels = 16; */
        for (let k of globalThis.Object.keys(message.specLabels))
            writer.tag(16, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.specLabels[k]).join();
        /* bool isUserHidden = 17; */
        if (message.isUserHidden !== false)
            writer.tag(17, WireType.Varint).bool(message.isUserHidden);
        /* bool isSystemHidden = 18; */
        if (message.isSystemHidden !== false)
            writer.tag(18, WireType.Varint).bool(message.isSystemHidden);
        /* map<string, string> systemLabels = 19; */
        for (let k of globalThis.Object.keys(message.systemLabels))
            writer.tag(19, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.systemLabels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectReference$Type extends MessageType<ObjectReference> {
    constructor() {
        super("octelium.api.main.meta.v1.ObjectReference", [
            { no: 1, name: "apiVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "resourceVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ObjectReference>): ObjectReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiVersion = "";
        message.kind = "";
        message.uid = "";
        message.name = "";
        message.resourceVersion = "";
        if (value !== undefined)
            reflectionMergePartial<ObjectReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectReference): ObjectReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string apiVersion */ 1:
                    message.apiVersion = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* string uid */ 3:
                    message.uid = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string resourceVersion */ 5:
                    message.resourceVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string apiVersion = 1; */
        if (message.apiVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiVersion);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string uid = 3; */
        if (message.uid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uid);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string resourceVersion = 5; */
        if (message.resourceVersion !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.resourceVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.ObjectReference
 */
export const ObjectReference = new ObjectReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Duration$Type extends MessageType<Duration> {
    constructor() {
        super("octelium.api.main.meta.v1.Duration", [
            { no: 1, name: "milliseconds", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "seconds", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "minutes", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hours", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "days", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "weeks", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "months", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Duration>): Duration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Duration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Duration): Duration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 milliseconds */ 1:
                    message.type = {
                        oneofKind: "milliseconds",
                        milliseconds: reader.uint32()
                    };
                    break;
                case /* uint32 seconds */ 2:
                    message.type = {
                        oneofKind: "seconds",
                        seconds: reader.uint32()
                    };
                    break;
                case /* uint32 minutes */ 3:
                    message.type = {
                        oneofKind: "minutes",
                        minutes: reader.uint32()
                    };
                    break;
                case /* uint32 hours */ 4:
                    message.type = {
                        oneofKind: "hours",
                        hours: reader.uint32()
                    };
                    break;
                case /* uint32 days */ 5:
                    message.type = {
                        oneofKind: "days",
                        days: reader.uint32()
                    };
                    break;
                case /* uint32 weeks */ 6:
                    message.type = {
                        oneofKind: "weeks",
                        weeks: reader.uint32()
                    };
                    break;
                case /* uint32 months */ 7:
                    message.type = {
                        oneofKind: "months",
                        months: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Duration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 milliseconds = 1; */
        if (message.type.oneofKind === "milliseconds")
            writer.tag(1, WireType.Varint).uint32(message.type.milliseconds);
        /* uint32 seconds = 2; */
        if (message.type.oneofKind === "seconds")
            writer.tag(2, WireType.Varint).uint32(message.type.seconds);
        /* uint32 minutes = 3; */
        if (message.type.oneofKind === "minutes")
            writer.tag(3, WireType.Varint).uint32(message.type.minutes);
        /* uint32 hours = 4; */
        if (message.type.oneofKind === "hours")
            writer.tag(4, WireType.Varint).uint32(message.type.hours);
        /* uint32 days = 5; */
        if (message.type.oneofKind === "days")
            writer.tag(5, WireType.Varint).uint32(message.type.days);
        /* uint32 weeks = 6; */
        if (message.type.oneofKind === "weeks")
            writer.tag(6, WireType.Varint).uint32(message.type.weeks);
        /* uint32 months = 7; */
        if (message.type.oneofKind === "months")
            writer.tag(7, WireType.Varint).uint32(message.type.months);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.Duration
 */
export const Duration = new Duration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteOptions$Type extends MessageType<DeleteOptions> {
    constructor() {
        super("octelium.api.main.meta.v1.DeleteOptions", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteOptions>): DeleteOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uid = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteOptions): DeleteOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.DeleteOptions
 */
export const DeleteOptions = new DeleteOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOptions$Type extends MessageType<GetOptions> {
    constructor() {
        super("octelium.api.main.meta.v1.GetOptions", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOptions>): GetOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uid = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOptions): GetOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.GetOptions
 */
export const GetOptions = new GetOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationResult$Type extends MessageType<OperationResult> {
    constructor() {
        super("octelium.api.main.meta.v1.OperationResult", []);
    }
    create(value?: PartialMessage<OperationResult>): OperationResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OperationResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationResult): OperationResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.OperationResult
 */
export const OperationResult = new OperationResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DualStackIP$Type extends MessageType<DualStackIP> {
    constructor() {
        super("octelium.api.main.meta.v1.DualStackIP", [
            { no: 1, name: "ipv4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ipv6", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DualStackIP>): DualStackIP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ipv4 = "";
        message.ipv6 = "";
        if (value !== undefined)
            reflectionMergePartial<DualStackIP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DualStackIP): DualStackIP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ipv4 */ 1:
                    message.ipv4 = reader.string();
                    break;
                case /* string ipv6 */ 2:
                    message.ipv6 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DualStackIP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ipv4 = 1; */
        if (message.ipv4 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ipv4);
        /* string ipv6 = 2; */
        if (message.ipv6 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ipv6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.DualStackIP
 */
export const DualStackIP = new DualStackIP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DualStackNetwork$Type extends MessageType<DualStackNetwork> {
    constructor() {
        super("octelium.api.main.meta.v1.DualStackNetwork", [
            { no: 1, name: "v4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "v6", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DualStackNetwork>): DualStackNetwork {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.v4 = "";
        message.v6 = "";
        if (value !== undefined)
            reflectionMergePartial<DualStackNetwork>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DualStackNetwork): DualStackNetwork {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string v4 */ 1:
                    message.v4 = reader.string();
                    break;
                case /* string v6 */ 2:
                    message.v6 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DualStackNetwork, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string v4 = 1; */
        if (message.v4 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.v4);
        /* string v6 = 2; */
        if (message.v6 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.v6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.DualStackNetwork
 */
export const DualStackNetwork = new DualStackNetwork$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListResponseMeta$Type extends MessageType<ListResponseMeta> {
    constructor() {
        super("octelium.api.main.meta.v1.ListResponseMeta", [
            { no: 1, name: "page", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "itemsPerPage", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "totalCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hasMore", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListResponseMeta>): ListResponseMeta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page = 0;
        message.itemsPerPage = 0;
        message.totalCount = 0;
        message.hasMore = false;
        if (value !== undefined)
            reflectionMergePartial<ListResponseMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListResponseMeta): ListResponseMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 page */ 1:
                    message.page = reader.uint32();
                    break;
                case /* uint32 itemsPerPage */ 2:
                    message.itemsPerPage = reader.uint32();
                    break;
                case /* uint32 totalCount */ 3:
                    message.totalCount = reader.uint32();
                    break;
                case /* bool hasMore */ 4:
                    message.hasMore = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListResponseMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 page = 1; */
        if (message.page !== 0)
            writer.tag(1, WireType.Varint).uint32(message.page);
        /* uint32 itemsPerPage = 2; */
        if (message.itemsPerPage !== 0)
            writer.tag(2, WireType.Varint).uint32(message.itemsPerPage);
        /* uint32 totalCount = 3; */
        if (message.totalCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.totalCount);
        /* bool hasMore = 4; */
        if (message.hasMore !== false)
            writer.tag(4, WireType.Varint).bool(message.hasMore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.ListResponseMeta
 */
export const ListResponseMeta = new ListResponseMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogMetadata$Type extends MessageType<LogMetadata> {
    constructor() {
        super("octelium.api.main.meta.v1.LogMetadata", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "createdAt", kind: "message", T: () => Timestamp },
            { no: 3, name: "actorRef", kind: "message", T: () => ObjectReference },
            { no: 4, name: "targetRef", kind: "message", T: () => ObjectReference }
        ]);
    }
    create(value?: PartialMessage<LogMetadata>): LogMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<LogMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogMetadata): LogMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* google.protobuf.Timestamp createdAt */ 2:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* octelium.api.main.meta.v1.ObjectReference actorRef */ 3:
                    message.actorRef = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.actorRef);
                    break;
                case /* octelium.api.main.meta.v1.ObjectReference targetRef */ 4:
                    message.targetRef = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.targetRef);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* google.protobuf.Timestamp createdAt = 2; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.meta.v1.ObjectReference actorRef = 3; */
        if (message.actorRef)
            ObjectReference.internalBinaryWrite(message.actorRef, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* octelium.api.main.meta.v1.ObjectReference targetRef = 4; */
        if (message.targetRef)
            ObjectReference.internalBinaryWrite(message.targetRef, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.LogMetadata
 */
export const LogMetadata = new LogMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonListOptions$Type extends MessageType<CommonListOptions> {
    constructor() {
        super("octelium.api.main.meta.v1.CommonListOptions", [
            { no: 1, name: "page", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "itemsPerPage", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "orderBy", kind: "message", T: () => CommonListOptions_OrderBy }
        ]);
    }
    create(value?: PartialMessage<CommonListOptions>): CommonListOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page = 0;
        message.itemsPerPage = 0;
        if (value !== undefined)
            reflectionMergePartial<CommonListOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonListOptions): CommonListOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 page */ 1:
                    message.page = reader.uint32();
                    break;
                case /* uint32 itemsPerPage */ 2:
                    message.itemsPerPage = reader.uint32();
                    break;
                case /* octelium.api.main.meta.v1.CommonListOptions.OrderBy orderBy */ 3:
                    message.orderBy = CommonListOptions_OrderBy.internalBinaryRead(reader, reader.uint32(), options, message.orderBy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonListOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 page = 1; */
        if (message.page !== 0)
            writer.tag(1, WireType.Varint).uint32(message.page);
        /* uint32 itemsPerPage = 2; */
        if (message.itemsPerPage !== 0)
            writer.tag(2, WireType.Varint).uint32(message.itemsPerPage);
        /* octelium.api.main.meta.v1.CommonListOptions.OrderBy orderBy = 3; */
        if (message.orderBy)
            CommonListOptions_OrderBy.internalBinaryWrite(message.orderBy, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.CommonListOptions
 */
export const CommonListOptions = new CommonListOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonListOptions_OrderBy$Type extends MessageType<CommonListOptions_OrderBy> {
    constructor() {
        super("octelium.api.main.meta.v1.CommonListOptions.OrderBy", [
            { no: 1, name: "type", kind: "enum", T: () => ["octelium.api.main.meta.v1.CommonListOptions.OrderBy.Type", CommonListOptions_OrderBy_Type] },
            { no: 2, name: "mode", kind: "enum", T: () => ["octelium.api.main.meta.v1.CommonListOptions.OrderBy.Mode", CommonListOptions_OrderBy_Mode] }
        ]);
    }
    create(value?: PartialMessage<CommonListOptions_OrderBy>): CommonListOptions_OrderBy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<CommonListOptions_OrderBy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonListOptions_OrderBy): CommonListOptions_OrderBy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* octelium.api.main.meta.v1.CommonListOptions.OrderBy.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* octelium.api.main.meta.v1.CommonListOptions.OrderBy.Mode mode */ 2:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonListOptions_OrderBy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* octelium.api.main.meta.v1.CommonListOptions.OrderBy.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* octelium.api.main.meta.v1.CommonListOptions.OrderBy.Mode mode = 2; */
        if (message.mode !== 0)
            writer.tag(2, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message octelium.api.main.meta.v1.CommonListOptions.OrderBy
 */
export const CommonListOptions_OrderBy = new CommonListOptions_OrderBy$Type();
