// Copyright Octelium Labs, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: userv1.proto

package userv1

import (
	context "context"
	metav1 "github.com/octelium/octelium/apis/main/metav1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MainService_Connect_FullMethodName           = "/octelium.api.main.user.v1.MainService/Connect"
	MainService_Disconnect_FullMethodName        = "/octelium.api.main.user.v1.MainService/Disconnect"
	MainService_ListService_FullMethodName       = "/octelium.api.main.user.v1.MainService/ListService"
	MainService_ListNamespace_FullMethodName     = "/octelium.api.main.user.v1.MainService/ListNamespace"
	MainService_GetStatus_FullMethodName         = "/octelium.api.main.user.v1.MainService/GetStatus"
	MainService_SetServiceConfigs_FullMethodName = "/octelium.api.main.user.v1.MainService/SetServiceConfigs"
	MainService_GetService_FullMethodName        = "/octelium.api.main.user.v1.MainService/GetService"
)

// MainServiceClient is the client API for MainService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MainServiceClient interface {
	// Connect connects to the Cluster
	Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectRequest, ConnectResponse], error)
	// Disconnect disconnects from a Cluster
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
	// ListService lists Services
	ListService(ctx context.Context, in *ListServiceOptions, opts ...grpc.CallOption) (*ServiceList, error)
	// ListNamespace lists Namespaces
	ListNamespace(ctx context.Context, in *ListNamespaceOptions, opts ...grpc.CallOption) (*NamespaceList, error)
	// GetStatus retrieves User status
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// SetServiceConfigs sets the Service configs needed to use the Service from
	// the client host (e.g. setting up kubeconfigs)
	SetServiceConfigs(ctx context.Context, in *SetServiceConfigsRequest, opts ...grpc.CallOption) (*SetServiceConfigsResponse, error)
	// GetService retrieves a Service
	GetService(ctx context.Context, in *metav1.GetOptions, opts ...grpc.CallOption) (*Service, error)
}

type mainServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMainServiceClient(cc grpc.ClientConnInterface) MainServiceClient {
	return &mainServiceClient{cc}
}

func (c *mainServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectRequest, ConnectResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MainService_ServiceDesc.Streams[0], MainService_Connect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConnectRequest, ConnectResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MainService_ConnectClient = grpc.BidiStreamingClient[ConnectRequest, ConnectResponse]

func (c *mainServiceClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectResponse)
	err := c.cc.Invoke(ctx, MainService_Disconnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mainServiceClient) ListService(ctx context.Context, in *ListServiceOptions, opts ...grpc.CallOption) (*ServiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceList)
	err := c.cc.Invoke(ctx, MainService_ListService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mainServiceClient) ListNamespace(ctx context.Context, in *ListNamespaceOptions, opts ...grpc.CallOption) (*NamespaceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NamespaceList)
	err := c.cc.Invoke(ctx, MainService_ListNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mainServiceClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, MainService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mainServiceClient) SetServiceConfigs(ctx context.Context, in *SetServiceConfigsRequest, opts ...grpc.CallOption) (*SetServiceConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetServiceConfigsResponse)
	err := c.cc.Invoke(ctx, MainService_SetServiceConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mainServiceClient) GetService(ctx context.Context, in *metav1.GetOptions, opts ...grpc.CallOption) (*Service, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Service)
	err := c.cc.Invoke(ctx, MainService_GetService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MainServiceServer is the server API for MainService service.
// All implementations must embed UnimplementedMainServiceServer
// for forward compatibility.
type MainServiceServer interface {
	// Connect connects to the Cluster
	Connect(grpc.BidiStreamingServer[ConnectRequest, ConnectResponse]) error
	// Disconnect disconnects from a Cluster
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
	// ListService lists Services
	ListService(context.Context, *ListServiceOptions) (*ServiceList, error)
	// ListNamespace lists Namespaces
	ListNamespace(context.Context, *ListNamespaceOptions) (*NamespaceList, error)
	// GetStatus retrieves User status
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// SetServiceConfigs sets the Service configs needed to use the Service from
	// the client host (e.g. setting up kubeconfigs)
	SetServiceConfigs(context.Context, *SetServiceConfigsRequest) (*SetServiceConfigsResponse, error)
	// GetService retrieves a Service
	GetService(context.Context, *metav1.GetOptions) (*Service, error)
	mustEmbedUnimplementedMainServiceServer()
}

// UnimplementedMainServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMainServiceServer struct{}

func (UnimplementedMainServiceServer) Connect(grpc.BidiStreamingServer[ConnectRequest, ConnectResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedMainServiceServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedMainServiceServer) ListService(context.Context, *ListServiceOptions) (*ServiceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListService not implemented")
}
func (UnimplementedMainServiceServer) ListNamespace(context.Context, *ListNamespaceOptions) (*NamespaceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamespace not implemented")
}
func (UnimplementedMainServiceServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedMainServiceServer) SetServiceConfigs(context.Context, *SetServiceConfigsRequest) (*SetServiceConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetServiceConfigs not implemented")
}
func (UnimplementedMainServiceServer) GetService(context.Context, *metav1.GetOptions) (*Service, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetService not implemented")
}
func (UnimplementedMainServiceServer) mustEmbedUnimplementedMainServiceServer() {}
func (UnimplementedMainServiceServer) testEmbeddedByValue()                     {}

// UnsafeMainServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MainServiceServer will
// result in compilation errors.
type UnsafeMainServiceServer interface {
	mustEmbedUnimplementedMainServiceServer()
}

func RegisterMainServiceServer(s grpc.ServiceRegistrar, srv MainServiceServer) {
	// If the following call pancis, it indicates UnimplementedMainServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MainService_ServiceDesc, srv)
}

func _MainService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MainServiceServer).Connect(&grpc.GenericServerStream[ConnectRequest, ConnectResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MainService_ConnectServer = grpc.BidiStreamingServer[ConnectRequest, ConnectResponse]

func _MainService_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MainServiceServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MainService_Disconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MainServiceServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MainService_ListService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServiceOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MainServiceServer).ListService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MainService_ListService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MainServiceServer).ListService(ctx, req.(*ListServiceOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _MainService_ListNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNamespaceOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MainServiceServer).ListNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MainService_ListNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MainServiceServer).ListNamespace(ctx, req.(*ListNamespaceOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _MainService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MainServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MainService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MainServiceServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MainService_SetServiceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetServiceConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MainServiceServer).SetServiceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MainService_SetServiceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MainServiceServer).SetServiceConfigs(ctx, req.(*SetServiceConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MainService_GetService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(metav1.GetOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MainServiceServer).GetService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MainService_GetService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MainServiceServer).GetService(ctx, req.(*metav1.GetOptions))
	}
	return interceptor(ctx, in, info, handler)
}

// MainService_ServiceDesc is the grpc.ServiceDesc for MainService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MainService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "octelium.api.main.user.v1.MainService",
	HandlerType: (*MainServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Disconnect",
			Handler:    _MainService_Disconnect_Handler,
		},
		{
			MethodName: "ListService",
			Handler:    _MainService_ListService_Handler,
		},
		{
			MethodName: "ListNamespace",
			Handler:    _MainService_ListNamespace_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _MainService_GetStatus_Handler,
		},
		{
			MethodName: "SetServiceConfigs",
			Handler:    _MainService_SetServiceConfigs_Handler,
		},
		{
			MethodName: "GetService",
			Handler:    _MainService_GetService_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _MainService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "userv1.proto",
}
